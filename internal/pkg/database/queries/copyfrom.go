// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package queries

import (
	"context"
)

// iteratorForBulkCreateGrammarItems implements pgx.CopyFromSource.
type iteratorForBulkCreateGrammarItems struct {
	rows                 []BulkCreateGrammarItemsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateGrammarItems) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateGrammarItems) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].StoryID,
		r.rows[0].LineNumber,
		r.rows[0].Text,
		r.rows[0].PositionStart,
		r.rows[0].PositionEnd,
	}, nil
}

func (r iteratorForBulkCreateGrammarItems) Err() error {
	return nil
}

func (q *Queries) BulkCreateGrammarItems(ctx context.Context, arg []BulkCreateGrammarItemsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"grammar_items"}, []string{"story_id", "line_number", "text", "position_start", "position_end"}, &iteratorForBulkCreateGrammarItems{rows: arg})
}

// iteratorForBulkCreateStoryLines implements pgx.CopyFromSource.
type iteratorForBulkCreateStoryLines struct {
	rows                 []BulkCreateStoryLinesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateStoryLines) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateStoryLines) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].StoryID,
		r.rows[0].LineNumber,
		r.rows[0].Text,
		r.rows[0].AudioFile,
	}, nil
}

func (r iteratorForBulkCreateStoryLines) Err() error {
	return nil
}

func (q *Queries) BulkCreateStoryLines(ctx context.Context, arg []BulkCreateStoryLinesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"story_lines"}, []string{"story_id", "line_number", "text", "audio_file"}, &iteratorForBulkCreateStoryLines{rows: arg})
}

// iteratorForBulkCreateVocabularyItems implements pgx.CopyFromSource.
type iteratorForBulkCreateVocabularyItems struct {
	rows                 []BulkCreateVocabularyItemsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateVocabularyItems) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateVocabularyItems) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].StoryID,
		r.rows[0].LineNumber,
		r.rows[0].Word,
		r.rows[0].LexicalForm,
		r.rows[0].PositionStart,
		r.rows[0].PositionEnd,
	}, nil
}

func (r iteratorForBulkCreateVocabularyItems) Err() error {
	return nil
}

func (q *Queries) BulkCreateVocabularyItems(ctx context.Context, arg []BulkCreateVocabularyItemsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"vocabulary_items"}, []string{"story_id", "line_number", "word", "lexical_form", "position_start", "position_end"}, &iteratorForBulkCreateVocabularyItems{rows: arg})
}
