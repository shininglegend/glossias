// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stories.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateGrammarItemsParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Text          string      `json:"text"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

type BulkCreateStoryLinesParams struct {
	StoryID    int32       `json:"story_id"`
	LineNumber int32       `json:"line_number"`
	Text       string      `json:"text"`
	AudioFile  pgtype.Text `json:"audio_file"`
}

type BulkCreateVocabularyItemsParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Word          string      `json:"word"`
	LexicalForm   string      `json:"lexical_form"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

const checkFootnoteExists = `-- name: CheckFootnoteExists :one
SELECT id FROM footnotes f
WHERE f.story_id = $1 AND f.line_number = $2 AND f.footnote_text = $3
LIMIT 1
`

type CheckFootnoteExistsParams struct {
	StoryID      pgtype.Int4 `json:"story_id"`
	LineNumber   pgtype.Int4 `json:"line_number"`
	FootnoteText string      `json:"footnote_text"`
}

func (q *Queries) CheckFootnoteExists(ctx context.Context, arg CheckFootnoteExistsParams) (int32, error) {
	row := q.db.QueryRow(ctx, checkFootnoteExists, arg.StoryID, arg.LineNumber, arg.FootnoteText)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const checkGrammarExists = `-- name: CheckGrammarExists :one
SELECT EXISTS(
    SELECT 1 FROM grammar_items
    WHERE story_id = $1 AND line_number = $2 AND text = $3
    AND position_start = $4 AND position_end = $5
)
`

type CheckGrammarExistsParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Text          string      `json:"text"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) CheckGrammarExists(ctx context.Context, arg CheckGrammarExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkGrammarExists,
		arg.StoryID,
		arg.LineNumber,
		arg.Text,
		arg.PositionStart,
		arg.PositionEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkVocabularyExists = `-- name: CheckVocabularyExists :one
SELECT EXISTS(
    SELECT 1 FROM vocabulary_items
    WHERE story_id = $1 AND line_number = $2 AND word = $3 AND lexical_form = $4
    AND position_start = $5 AND position_end = $6
)
`

type CheckVocabularyExistsParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Word          string      `json:"word"`
	LexicalForm   string      `json:"lexical_form"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) CheckVocabularyExists(ctx context.Context, arg CheckVocabularyExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkVocabularyExists,
		arg.StoryID,
		arg.LineNumber,
		arg.Word,
		arg.LexicalForm,
		arg.PositionStart,
		arg.PositionEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createFootnote = `-- name: CreateFootnote :one
INSERT INTO footnotes (story_id, line_number, footnote_text)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateFootnoteParams struct {
	StoryID      pgtype.Int4 `json:"story_id"`
	LineNumber   pgtype.Int4 `json:"line_number"`
	FootnoteText string      `json:"footnote_text"`
}

func (q *Queries) CreateFootnote(ctx context.Context, arg CreateFootnoteParams) (int32, error) {
	row := q.db.QueryRow(ctx, createFootnote, arg.StoryID, arg.LineNumber, arg.FootnoteText)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createFootnoteReference = `-- name: CreateFootnoteReference :exec
INSERT INTO footnote_references (footnote_id, reference)
VALUES ($1, $2)
`

type CreateFootnoteReferenceParams struct {
	FootnoteID int32  `json:"footnote_id"`
	Reference  string `json:"reference"`
}

func (q *Queries) CreateFootnoteReference(ctx context.Context, arg CreateFootnoteReferenceParams) error {
	_, err := q.db.Exec(ctx, createFootnoteReference, arg.FootnoteID, arg.Reference)
	return err
}

const createGrammarItem = `-- name: CreateGrammarItem :one
INSERT INTO grammar_items (story_id, line_number, text, position_start, position_end)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type CreateGrammarItemParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Text          string      `json:"text"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) CreateGrammarItem(ctx context.Context, arg CreateGrammarItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, createGrammarItem,
		arg.StoryID,
		arg.LineNumber,
		arg.Text,
		arg.PositionStart,
		arg.PositionEnd,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createStory = `-- name: CreateStory :one
INSERT INTO stories (week_number, day_letter, grammar_point, author_id, author_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING story_id, last_revision
`

type CreateStoryParams struct {
	WeekNumber   int32       `json:"week_number"`
	DayLetter    string      `json:"day_letter"`
	GrammarPoint pgtype.Text `json:"grammar_point"`
	AuthorID     string      `json:"author_id"`
	AuthorName   string      `json:"author_name"`
}

type CreateStoryRow struct {
	StoryID      int32            `json:"story_id"`
	LastRevision pgtype.Timestamp `json:"last_revision"`
}

func (q *Queries) CreateStory(ctx context.Context, arg CreateStoryParams) (CreateStoryRow, error) {
	row := q.db.QueryRow(ctx, createStory,
		arg.WeekNumber,
		arg.DayLetter,
		arg.GrammarPoint,
		arg.AuthorID,
		arg.AuthorName,
	)
	var i CreateStoryRow
	err := row.Scan(&i.StoryID, &i.LastRevision)
	return i, err
}

const createVocabularyItem = `-- name: CreateVocabularyItem :one
INSERT INTO vocabulary_items (story_id, line_number, word, lexical_form, position_start, position_end)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateVocabularyItemParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Word          string      `json:"word"`
	LexicalForm   string      `json:"lexical_form"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) CreateVocabularyItem(ctx context.Context, arg CreateVocabularyItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, createVocabularyItem,
		arg.StoryID,
		arg.LineNumber,
		arg.Word,
		arg.LexicalForm,
		arg.PositionStart,
		arg.PositionEnd,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteAllGrammarForStory = `-- name: DeleteAllGrammarForStory :exec
DELETE FROM grammar_items WHERE story_id = $1
`

func (q *Queries) DeleteAllGrammarForStory(ctx context.Context, storyID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteAllGrammarForStory, storyID)
	return err
}

const deleteAllLineAnnotations = `-- name: DeleteAllLineAnnotations :exec
DELETE FROM footnotes WHERE story_id = $1 AND line_number = $2
`

type DeleteAllLineAnnotationsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) DeleteAllLineAnnotations(ctx context.Context, arg DeleteAllLineAnnotationsParams) error {
	_, err := q.db.Exec(ctx, deleteAllLineAnnotations, arg.StoryID, arg.LineNumber)
	return err
}

const deleteAllStoryAnnotations = `-- name: DeleteAllStoryAnnotations :exec
DELETE FROM footnotes WHERE story_id = $1
`

func (q *Queries) DeleteAllStoryAnnotations(ctx context.Context, storyID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteAllStoryAnnotations, storyID)
	return err
}

const deleteAllStoryLines = `-- name: DeleteAllStoryLines :exec
DELETE FROM story_lines WHERE story_id = $1
`

func (q *Queries) DeleteAllStoryLines(ctx context.Context, storyID int32) error {
	_, err := q.db.Exec(ctx, deleteAllStoryLines, storyID)
	return err
}

const deleteAllVocabularyForStory = `-- name: DeleteAllVocabularyForStory :exec
DELETE FROM vocabulary_items WHERE story_id = $1
`

func (q *Queries) DeleteAllVocabularyForStory(ctx context.Context, storyID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteAllVocabularyForStory, storyID)
	return err
}

const deleteFootnote = `-- name: DeleteFootnote :exec
DELETE FROM footnotes WHERE id = $1
`

func (q *Queries) DeleteFootnote(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteFootnote, id)
	return err
}

const deleteFootnoteReferences = `-- name: DeleteFootnoteReferences :exec
DELETE FROM footnote_references WHERE footnote_id = $1
`

func (q *Queries) DeleteFootnoteReferences(ctx context.Context, footnoteID int32) error {
	_, err := q.db.Exec(ctx, deleteFootnoteReferences, footnoteID)
	return err
}

const deleteGrammarItem = `-- name: DeleteGrammarItem :exec
DELETE FROM grammar_items WHERE id = $1
`

func (q *Queries) DeleteGrammarItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteGrammarItem, id)
	return err
}

const deleteGrammarItems = `-- name: DeleteGrammarItems :exec
DELETE FROM grammar_items WHERE story_id = $1 AND line_number = $2
`

type DeleteGrammarItemsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) DeleteGrammarItems(ctx context.Context, arg DeleteGrammarItemsParams) error {
	_, err := q.db.Exec(ctx, deleteGrammarItems, arg.StoryID, arg.LineNumber)
	return err
}

const deleteStory = `-- name: DeleteStory :exec
DELETE FROM stories WHERE story_id = $1
`

func (q *Queries) DeleteStory(ctx context.Context, storyID int32) error {
	_, err := q.db.Exec(ctx, deleteStory, storyID)
	return err
}

const deleteStoryDescriptions = `-- name: DeleteStoryDescriptions :exec
DELETE FROM story_descriptions WHERE story_id = $1
`

func (q *Queries) DeleteStoryDescriptions(ctx context.Context, storyID int32) error {
	_, err := q.db.Exec(ctx, deleteStoryDescriptions, storyID)
	return err
}

const deleteStoryLine = `-- name: DeleteStoryLine :exec
DELETE FROM story_lines WHERE story_id = $1 AND line_number = $2
`

type DeleteStoryLineParams struct {
	StoryID    int32 `json:"story_id"`
	LineNumber int32 `json:"line_number"`
}

func (q *Queries) DeleteStoryLine(ctx context.Context, arg DeleteStoryLineParams) error {
	_, err := q.db.Exec(ctx, deleteStoryLine, arg.StoryID, arg.LineNumber)
	return err
}

const deleteStoryTitles = `-- name: DeleteStoryTitles :exec
DELETE FROM story_titles WHERE story_id = $1
`

func (q *Queries) DeleteStoryTitles(ctx context.Context, storyID int32) error {
	_, err := q.db.Exec(ctx, deleteStoryTitles, storyID)
	return err
}

const deleteVocabularyItem = `-- name: DeleteVocabularyItem :exec
DELETE FROM vocabulary_items WHERE id = $1
`

func (q *Queries) DeleteVocabularyItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVocabularyItem, id)
	return err
}

const deleteVocabularyItems = `-- name: DeleteVocabularyItems :exec
DELETE FROM vocabulary_items WHERE story_id = $1 AND line_number = $2
`

type DeleteVocabularyItemsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) DeleteVocabularyItems(ctx context.Context, arg DeleteVocabularyItemsParams) error {
	_, err := q.db.Exec(ctx, deleteVocabularyItems, arg.StoryID, arg.LineNumber)
	return err
}

const getAllAnnotationsForStory = `-- name: GetAllAnnotationsForStory :many
SELECT 'vocabulary' as type, v.line_number, v.word as text, v.lexical_form as extra, v.position_start, v.position_end, 0 as footnote_id
FROM vocabulary_items v
WHERE v.story_id = $1
UNION ALL
SELECT 'grammar' as type, g.line_number, g.text, '' as extra, g.position_start, g.position_end, 0 as footnote_id
FROM grammar_items g
WHERE g.story_id = $1
UNION ALL
SELECT 'footnote' as type, f.line_number, f.footnote_text as text, '' as extra, 0 as position_start, 0 as position_end, f.id as footnote_id
FROM footnotes f
WHERE f.story_id = $1
ORDER BY line_number, position_start
`

type GetAllAnnotationsForStoryRow struct {
	Type          string      `json:"type"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Text          string      `json:"text"`
	Extra         string      `json:"extra"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
	FootnoteID    int32       `json:"footnote_id"`
}

func (q *Queries) GetAllAnnotationsForStory(ctx context.Context, storyID pgtype.Int4) ([]GetAllAnnotationsForStoryRow, error) {
	rows, err := q.db.Query(ctx, getAllAnnotationsForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAnnotationsForStoryRow{}
	for rows.Next() {
		var i GetAllAnnotationsForStoryRow
		if err := rows.Scan(
			&i.Type,
			&i.LineNumber,
			&i.Text,
			&i.Extra,
			&i.PositionStart,
			&i.PositionEnd,
			&i.FootnoteID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFootnotesForStory = `-- name: GetAllFootnotesForStory :many
SELECT f.line_number, f.id, f.footnote_text
FROM footnotes f
WHERE f.story_id = $1
ORDER BY f.line_number, f.id
`

type GetAllFootnotesForStoryRow struct {
	LineNumber   pgtype.Int4 `json:"line_number"`
	ID           int32       `json:"id"`
	FootnoteText string      `json:"footnote_text"`
}

func (q *Queries) GetAllFootnotesForStory(ctx context.Context, storyID pgtype.Int4) ([]GetAllFootnotesForStoryRow, error) {
	rows, err := q.db.Query(ctx, getAllFootnotesForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllFootnotesForStoryRow{}
	for rows.Next() {
		var i GetAllFootnotesForStoryRow
		if err := rows.Scan(&i.LineNumber, &i.ID, &i.FootnoteText); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllGrammarForStory = `-- name: GetAllGrammarForStory :many
SELECT line_number, text, position_start, position_end
FROM grammar_items
WHERE story_id = $1
ORDER BY line_number, position_start
`

type GetAllGrammarForStoryRow struct {
	LineNumber    pgtype.Int4 `json:"line_number"`
	Text          string      `json:"text"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) GetAllGrammarForStory(ctx context.Context, storyID pgtype.Int4) ([]GetAllGrammarForStoryRow, error) {
	rows, err := q.db.Query(ctx, getAllGrammarForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllGrammarForStoryRow{}
	for rows.Next() {
		var i GetAllGrammarForStoryRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.Text,
			&i.PositionStart,
			&i.PositionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStories = `-- name: GetAllStories :many
SELECT s.story_id, s.week_number, s.day_letter, s.grammar_point, s.last_revision, s.author_id, s.author_name
FROM stories s
ORDER BY s.week_number, s.day_letter
`

func (q *Queries) GetAllStories(ctx context.Context) ([]Story, error) {
	rows, err := q.db.Query(ctx, getAllStories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Story{}
	for rows.Next() {
		var i Story
		if err := rows.Scan(
			&i.StoryID,
			&i.WeekNumber,
			&i.DayLetter,
			&i.GrammarPoint,
			&i.LastRevision,
			&i.AuthorID,
			&i.AuthorName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStoriesBasic = `-- name: GetAllStoriesBasic :many
SELECT DISTINCT s.story_id, s.week_number, s.day_letter, st.title
FROM stories s
JOIN story_titles st ON s.story_id = st.story_id
WHERE st.language_code = $1 OR $1 = ''
ORDER BY s.week_number, s.day_letter
`

type GetAllStoriesBasicRow struct {
	StoryID    int32  `json:"story_id"`
	WeekNumber int32  `json:"week_number"`
	DayLetter  string `json:"day_letter"`
	Title      string `json:"title"`
}

func (q *Queries) GetAllStoriesBasic(ctx context.Context, languageCode string) ([]GetAllStoriesBasicRow, error) {
	rows, err := q.db.Query(ctx, getAllStoriesBasic, languageCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllStoriesBasicRow{}
	for rows.Next() {
		var i GetAllStoriesBasicRow
		if err := rows.Scan(
			&i.StoryID,
			&i.WeekNumber,
			&i.DayLetter,
			&i.Title,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllStoriesWithTitles = `-- name: GetAllStoriesWithTitles :many
SELECT DISTINCT s.story_id, s.week_number, s.day_letter, st.title, st.language_code
FROM stories s
JOIN story_titles st ON s.story_id = st.story_id
ORDER BY s.week_number, s.day_letter
`

type GetAllStoriesWithTitlesRow struct {
	StoryID      int32  `json:"story_id"`
	WeekNumber   int32  `json:"week_number"`
	DayLetter    string `json:"day_letter"`
	Title        string `json:"title"`
	LanguageCode string `json:"language_code"`
}

func (q *Queries) GetAllStoriesWithTitles(ctx context.Context) ([]GetAllStoriesWithTitlesRow, error) {
	rows, err := q.db.Query(ctx, getAllStoriesWithTitles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllStoriesWithTitlesRow{}
	for rows.Next() {
		var i GetAllStoriesWithTitlesRow
		if err := rows.Scan(
			&i.StoryID,
			&i.WeekNumber,
			&i.DayLetter,
			&i.Title,
			&i.LanguageCode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVocabularyForStory = `-- name: GetAllVocabularyForStory :many
SELECT line_number, word, lexical_form, position_start, position_end
FROM vocabulary_items
WHERE story_id = $1
ORDER BY line_number, position_start
`

type GetAllVocabularyForStoryRow struct {
	LineNumber    pgtype.Int4 `json:"line_number"`
	Word          string      `json:"word"`
	LexicalForm   string      `json:"lexical_form"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) GetAllVocabularyForStory(ctx context.Context, storyID pgtype.Int4) ([]GetAllVocabularyForStoryRow, error) {
	rows, err := q.db.Query(ctx, getAllVocabularyForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllVocabularyForStoryRow{}
	for rows.Next() {
		var i GetAllVocabularyForStoryRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.Word,
			&i.LexicalForm,
			&i.PositionStart,
			&i.PositionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootnoteReferences = `-- name: GetFootnoteReferences :many
SELECT reference
FROM footnote_references
WHERE footnote_id = $1
`

func (q *Queries) GetFootnoteReferences(ctx context.Context, footnoteID int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getFootnoteReferences, footnoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var reference string
		if err := rows.Scan(&reference); err != nil {
			return nil, err
		}
		items = append(items, reference)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootnotes = `-- name: GetFootnotes :many
SELECT f.id, f.story_id, f.line_number, f.footnote_text
FROM footnotes f
WHERE f.story_id = $1 AND f.line_number = $2
`

type GetFootnotesParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) GetFootnotes(ctx context.Context, arg GetFootnotesParams) ([]Footnote, error) {
	rows, err := q.db.Query(ctx, getFootnotes, arg.StoryID, arg.LineNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Footnote{}
	for rows.Next() {
		var i Footnote
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.LineNumber,
			&i.FootnoteText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGrammarItems = `-- name: GetGrammarItems :many
SELECT id, story_id, line_number, text, position_start, position_end
FROM grammar_items
WHERE story_id = $1 AND line_number = $2
ORDER BY position_start
`

type GetGrammarItemsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) GetGrammarItems(ctx context.Context, arg GetGrammarItemsParams) ([]GrammarItem, error) {
	rows, err := q.db.Query(ctx, getGrammarItems, arg.StoryID, arg.LineNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GrammarItem{}
	for rows.Next() {
		var i GrammarItem
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.LineNumber,
			&i.Text,
			&i.PositionStart,
			&i.PositionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLineText = `-- name: GetLineText :one
SELECT text FROM story_lines
WHERE story_id = $1 AND line_number = $2
`

type GetLineTextParams struct {
	StoryID    int32 `json:"story_id"`
	LineNumber int32 `json:"line_number"`
}

func (q *Queries) GetLineText(ctx context.Context, arg GetLineTextParams) (string, error) {
	row := q.db.QueryRow(ctx, getLineText, arg.StoryID, arg.LineNumber)
	var text string
	err := row.Scan(&text)
	return text, err
}

const getStory = `-- name: GetStory :one
SELECT s.story_id, s.week_number, s.day_letter, s.grammar_point, s.last_revision, s.author_id, s.author_name
FROM stories s
WHERE s.story_id = $1
`

func (q *Queries) GetStory(ctx context.Context, storyID int32) (Story, error) {
	row := q.db.QueryRow(ctx, getStory, storyID)
	var i Story
	err := row.Scan(
		&i.StoryID,
		&i.WeekNumber,
		&i.DayLetter,
		&i.GrammarPoint,
		&i.LastRevision,
		&i.AuthorID,
		&i.AuthorName,
	)
	return i, err
}

const getStoryDescription = `-- name: GetStoryDescription :one
SELECT description_text
FROM story_descriptions
WHERE story_id = $1 AND language_code = $2
`

type GetStoryDescriptionParams struct {
	StoryID      int32  `json:"story_id"`
	LanguageCode string `json:"language_code"`
}

func (q *Queries) GetStoryDescription(ctx context.Context, arg GetStoryDescriptionParams) (string, error) {
	row := q.db.QueryRow(ctx, getStoryDescription, arg.StoryID, arg.LanguageCode)
	var description_text string
	err := row.Scan(&description_text)
	return description_text, err
}

const getStoryFootnotesWithReferences = `-- name: GetStoryFootnotesWithReferences :many
SELECT f.id, f.line_number, f.footnote_text, array_agg(fr.reference ORDER BY fr.reference) as references
FROM footnotes f
LEFT JOIN footnote_references fr ON f.id = fr.footnote_id
WHERE f.story_id = $1
GROUP BY f.id, f.line_number, f.footnote_text
ORDER BY f.line_number, f.id
`

type GetStoryFootnotesWithReferencesRow struct {
	ID           int32       `json:"id"`
	LineNumber   pgtype.Int4 `json:"line_number"`
	FootnoteText string      `json:"footnote_text"`
	References   interface{} `json:"references"`
}

func (q *Queries) GetStoryFootnotesWithReferences(ctx context.Context, storyID pgtype.Int4) ([]GetStoryFootnotesWithReferencesRow, error) {
	rows, err := q.db.Query(ctx, getStoryFootnotesWithReferences, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoryFootnotesWithReferencesRow{}
	for rows.Next() {
		var i GetStoryFootnotesWithReferencesRow
		if err := rows.Scan(
			&i.ID,
			&i.LineNumber,
			&i.FootnoteText,
			&i.References,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryLine = `-- name: GetStoryLine :one
SELECT story_id, line_number, text, audio_file
FROM story_lines
WHERE story_id = $1 AND line_number = $2
`

type GetStoryLineParams struct {
	StoryID    int32 `json:"story_id"`
	LineNumber int32 `json:"line_number"`
}

func (q *Queries) GetStoryLine(ctx context.Context, arg GetStoryLineParams) (StoryLine, error) {
	row := q.db.QueryRow(ctx, getStoryLine, arg.StoryID, arg.LineNumber)
	var i StoryLine
	err := row.Scan(
		&i.StoryID,
		&i.LineNumber,
		&i.Text,
		&i.AudioFile,
	)
	return i, err
}

const getStoryLines = `-- name: GetStoryLines :many
SELECT story_id, line_number, text, audio_file
FROM story_lines
WHERE story_id = $1
ORDER BY line_number
`

func (q *Queries) GetStoryLines(ctx context.Context, storyID int32) ([]StoryLine, error) {
	rows, err := q.db.Query(ctx, getStoryLines, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StoryLine{}
	for rows.Next() {
		var i StoryLine
		if err := rows.Scan(
			&i.StoryID,
			&i.LineNumber,
			&i.Text,
			&i.AudioFile,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryTitle = `-- name: GetStoryTitle :one
SELECT title
FROM story_titles
WHERE story_id = $1 AND language_code = $2
`

type GetStoryTitleParams struct {
	StoryID      int32  `json:"story_id"`
	LanguageCode string `json:"language_code"`
}

func (q *Queries) GetStoryTitle(ctx context.Context, arg GetStoryTitleParams) (string, error) {
	row := q.db.QueryRow(ctx, getStoryTitle, arg.StoryID, arg.LanguageCode)
	var title string
	err := row.Scan(&title)
	return title, err
}

const getStoryTitles = `-- name: GetStoryTitles :many
SELECT story_id, language_code, title
FROM story_titles
WHERE story_id = $1
`

func (q *Queries) GetStoryTitles(ctx context.Context, storyID int32) ([]StoryTitle, error) {
	rows, err := q.db.Query(ctx, getStoryTitles, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []StoryTitle{}
	for rows.Next() {
		var i StoryTitle
		if err := rows.Scan(&i.StoryID, &i.LanguageCode, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryWithAllTitles = `-- name: GetStoryWithAllTitles :one
SELECT s.story_id, s.week_number, s.day_letter, s.grammar_point, s.last_revision, s.author_id, s.author_name
FROM stories s
WHERE s.story_id = $1
`

func (q *Queries) GetStoryWithAllTitles(ctx context.Context, storyID int32) (Story, error) {
	row := q.db.QueryRow(ctx, getStoryWithAllTitles, storyID)
	var i Story
	err := row.Scan(
		&i.StoryID,
		&i.WeekNumber,
		&i.DayLetter,
		&i.GrammarPoint,
		&i.LastRevision,
		&i.AuthorID,
		&i.AuthorName,
	)
	return i, err
}

const getStoryWithDescription = `-- name: GetStoryWithDescription :one
SELECT s.story_id, s.week_number, s.day_letter, s.grammar_point, s.last_revision, s.author_id, s.author_name,
       sd.language_code, sd.description_text
FROM stories s
LEFT JOIN story_descriptions sd ON s.story_id = sd.story_id
WHERE s.story_id = $1
`

type GetStoryWithDescriptionRow struct {
	StoryID         int32            `json:"story_id"`
	WeekNumber      int32            `json:"week_number"`
	DayLetter       string           `json:"day_letter"`
	GrammarPoint    pgtype.Text      `json:"grammar_point"`
	LastRevision    pgtype.Timestamp `json:"last_revision"`
	AuthorID        string           `json:"author_id"`
	AuthorName      string           `json:"author_name"`
	LanguageCode    pgtype.Text      `json:"language_code"`
	DescriptionText pgtype.Text      `json:"description_text"`
}

func (q *Queries) GetStoryWithDescription(ctx context.Context, storyID int32) (GetStoryWithDescriptionRow, error) {
	row := q.db.QueryRow(ctx, getStoryWithDescription, storyID)
	var i GetStoryWithDescriptionRow
	err := row.Scan(
		&i.StoryID,
		&i.WeekNumber,
		&i.DayLetter,
		&i.GrammarPoint,
		&i.LastRevision,
		&i.AuthorID,
		&i.AuthorName,
		&i.LanguageCode,
		&i.DescriptionText,
	)
	return i, err
}

const getVocabularyItems = `-- name: GetVocabularyItems :many
SELECT id, story_id, line_number, word, lexical_form, position_start, position_end
FROM vocabulary_items
WHERE story_id = $1 AND line_number = $2
ORDER BY position_start
`

type GetVocabularyItemsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) GetVocabularyItems(ctx context.Context, arg GetVocabularyItemsParams) ([]VocabularyItem, error) {
	rows, err := q.db.Query(ctx, getVocabularyItems, arg.StoryID, arg.LineNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VocabularyItem{}
	for rows.Next() {
		var i VocabularyItem
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.LineNumber,
			&i.Word,
			&i.LexicalForm,
			&i.PositionStart,
			&i.PositionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lineExists = `-- name: LineExists :one
SELECT EXISTS(SELECT 1 FROM story_lines WHERE story_id = $1 AND line_number = $2)
`

type LineExistsParams struct {
	StoryID    int32 `json:"story_id"`
	LineNumber int32 `json:"line_number"`
}

func (q *Queries) LineExists(ctx context.Context, arg LineExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, lineExists, arg.StoryID, arg.LineNumber)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const storyExists = `-- name: StoryExists :one
SELECT EXISTS(SELECT 1 FROM stories WHERE story_id = $1)
`

func (q *Queries) StoryExists(ctx context.Context, storyID int32) (bool, error) {
	row := q.db.QueryRow(ctx, storyExists, storyID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateFootnote = `-- name: UpdateFootnote :exec
UPDATE footnotes
SET footnote_text = $3
WHERE id = $1 AND story_id = $2
`

type UpdateFootnoteParams struct {
	ID           int32       `json:"id"`
	StoryID      pgtype.Int4 `json:"story_id"`
	FootnoteText string      `json:"footnote_text"`
}

func (q *Queries) UpdateFootnote(ctx context.Context, arg UpdateFootnoteParams) error {
	_, err := q.db.Exec(ctx, updateFootnote, arg.ID, arg.StoryID, arg.FootnoteText)
	return err
}

const updateGrammarByPosition = `-- name: UpdateGrammarByPosition :exec
UPDATE grammar_items
SET text = $5, position_start = $6, position_end = $7
WHERE story_id = $1 AND line_number = $2 AND position_start = $3 AND position_end = $4
`

type UpdateGrammarByPositionParams struct {
	StoryID         pgtype.Int4 `json:"story_id"`
	LineNumber      pgtype.Int4 `json:"line_number"`
	PositionStart   int32       `json:"position_start"`
	PositionEnd     int32       `json:"position_end"`
	Text            string      `json:"text"`
	PositionStart_2 int32       `json:"position_start_2"`
	PositionEnd_2   int32       `json:"position_end_2"`
}

func (q *Queries) UpdateGrammarByPosition(ctx context.Context, arg UpdateGrammarByPositionParams) error {
	_, err := q.db.Exec(ctx, updateGrammarByPosition,
		arg.StoryID,
		arg.LineNumber,
		arg.PositionStart,
		arg.PositionEnd,
		arg.Text,
		arg.PositionStart_2,
		arg.PositionEnd_2,
	)
	return err
}

const updateStory = `-- name: UpdateStory :exec
UPDATE stories
SET week_number = $2, day_letter = $3, grammar_point = $4, author_id = $5, author_name = $6, last_revision = CURRENT_TIMESTAMP
WHERE story_id = $1
`

type UpdateStoryParams struct {
	StoryID      int32       `json:"story_id"`
	WeekNumber   int32       `json:"week_number"`
	DayLetter    string      `json:"day_letter"`
	GrammarPoint pgtype.Text `json:"grammar_point"`
	AuthorID     string      `json:"author_id"`
	AuthorName   string      `json:"author_name"`
}

func (q *Queries) UpdateStory(ctx context.Context, arg UpdateStoryParams) error {
	_, err := q.db.Exec(ctx, updateStory,
		arg.StoryID,
		arg.WeekNumber,
		arg.DayLetter,
		arg.GrammarPoint,
		arg.AuthorID,
		arg.AuthorName,
	)
	return err
}

const updateStoryRevision = `-- name: UpdateStoryRevision :exec
UPDATE stories
SET last_revision = CURRENT_TIMESTAMP
WHERE story_id = $1
`

func (q *Queries) UpdateStoryRevision(ctx context.Context, storyID int32) error {
	_, err := q.db.Exec(ctx, updateStoryRevision, storyID)
	return err
}

const updateVocabularyByPosition = `-- name: UpdateVocabularyByPosition :exec
UPDATE vocabulary_items
SET word = $5, lexical_form = $6, position_start = $7, position_end = $8
WHERE story_id = $1 AND line_number = $2 AND position_start = $3 AND position_end = $4
`

type UpdateVocabularyByPositionParams struct {
	StoryID         pgtype.Int4 `json:"story_id"`
	LineNumber      pgtype.Int4 `json:"line_number"`
	PositionStart   int32       `json:"position_start"`
	PositionEnd     int32       `json:"position_end"`
	Word            string      `json:"word"`
	LexicalForm     string      `json:"lexical_form"`
	PositionStart_2 int32       `json:"position_start_2"`
	PositionEnd_2   int32       `json:"position_end_2"`
}

func (q *Queries) UpdateVocabularyByPosition(ctx context.Context, arg UpdateVocabularyByPositionParams) error {
	_, err := q.db.Exec(ctx, updateVocabularyByPosition,
		arg.StoryID,
		arg.LineNumber,
		arg.PositionStart,
		arg.PositionEnd,
		arg.Word,
		arg.LexicalForm,
		arg.PositionStart_2,
		arg.PositionEnd_2,
	)
	return err
}

const updateVocabularyByWord = `-- name: UpdateVocabularyByWord :exec
UPDATE vocabulary_items
SET lexical_form = $4
WHERE story_id = $1 AND line_number = $2 AND word = $3
`

type UpdateVocabularyByWordParams struct {
	StoryID     pgtype.Int4 `json:"story_id"`
	LineNumber  pgtype.Int4 `json:"line_number"`
	Word        string      `json:"word"`
	LexicalForm string      `json:"lexical_form"`
}

func (q *Queries) UpdateVocabularyByWord(ctx context.Context, arg UpdateVocabularyByWordParams) error {
	_, err := q.db.Exec(ctx, updateVocabularyByWord,
		arg.StoryID,
		arg.LineNumber,
		arg.Word,
		arg.LexicalForm,
	)
	return err
}

const updateVocabularyItem = `-- name: UpdateVocabularyItem :exec
UPDATE vocabulary_items
SET word = $2, lexical_form = $3, position_start = $4, position_end = $5
WHERE id = $1
`

type UpdateVocabularyItemParams struct {
	ID            int32  `json:"id"`
	Word          string `json:"word"`
	LexicalForm   string `json:"lexical_form"`
	PositionStart int32  `json:"position_start"`
	PositionEnd   int32  `json:"position_end"`
}

func (q *Queries) UpdateVocabularyItem(ctx context.Context, arg UpdateVocabularyItemParams) error {
	_, err := q.db.Exec(ctx, updateVocabularyItem,
		arg.ID,
		arg.Word,
		arg.LexicalForm,
		arg.PositionStart,
		arg.PositionEnd,
	)
	return err
}

const upsertStoryDescription = `-- name: UpsertStoryDescription :exec
INSERT INTO story_descriptions (story_id, language_code, description_text)
VALUES ($1, $2, $3)
ON CONFLICT (story_id, language_code)
DO UPDATE SET description_text = EXCLUDED.description_text
`

type UpsertStoryDescriptionParams struct {
	StoryID         int32  `json:"story_id"`
	LanguageCode    string `json:"language_code"`
	DescriptionText string `json:"description_text"`
}

func (q *Queries) UpsertStoryDescription(ctx context.Context, arg UpsertStoryDescriptionParams) error {
	_, err := q.db.Exec(ctx, upsertStoryDescription, arg.StoryID, arg.LanguageCode, arg.DescriptionText)
	return err
}

const upsertStoryLine = `-- name: UpsertStoryLine :exec
INSERT INTO story_lines (story_id, line_number, text, audio_file)
VALUES ($1, $2, $3, $4)
ON CONFLICT (story_id, line_number)
DO UPDATE SET text = EXCLUDED.text, audio_file = EXCLUDED.audio_file
`

type UpsertStoryLineParams struct {
	StoryID    int32       `json:"story_id"`
	LineNumber int32       `json:"line_number"`
	Text       string      `json:"text"`
	AudioFile  pgtype.Text `json:"audio_file"`
}

func (q *Queries) UpsertStoryLine(ctx context.Context, arg UpsertStoryLineParams) error {
	_, err := q.db.Exec(ctx, upsertStoryLine,
		arg.StoryID,
		arg.LineNumber,
		arg.Text,
		arg.AudioFile,
	)
	return err
}

const upsertStoryTitle = `-- name: UpsertStoryTitle :exec
INSERT INTO story_titles (story_id, language_code, title)
VALUES ($1, $2, $3)
ON CONFLICT (story_id, language_code)
DO UPDATE SET title = EXCLUDED.title
`

type UpsertStoryTitleParams struct {
	StoryID      int32  `json:"story_id"`
	LanguageCode string `json:"language_code"`
	Title        string `json:"title"`
}

func (q *Queries) UpsertStoryTitle(ctx context.Context, arg UpsertStoryTitleParams) error {
	_, err := q.db.Exec(ctx, upsertStoryTitle, arg.StoryID, arg.LanguageCode, arg.Title)
	return err
}
