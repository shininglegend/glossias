// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: annotations.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFootnote = `-- name: CreateFootnote :one
INSERT INTO footnotes (story_id, line_number, footnote_text)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateFootnoteParams struct {
	StoryID      pgtype.Int4 `json:"story_id"`
	LineNumber   pgtype.Int4 `json:"line_number"`
	FootnoteText string      `json:"footnote_text"`
}

func (q *Queries) CreateFootnote(ctx context.Context, arg CreateFootnoteParams) (int32, error) {
	row := q.db.QueryRow(ctx, createFootnote, arg.StoryID, arg.LineNumber, arg.FootnoteText)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createFootnoteReference = `-- name: CreateFootnoteReference :exec
INSERT INTO footnote_references (footnote_id, reference)
VALUES ($1, $2)
`

type CreateFootnoteReferenceParams struct {
	FootnoteID int32  `json:"footnote_id"`
	Reference  string `json:"reference"`
}

func (q *Queries) CreateFootnoteReference(ctx context.Context, arg CreateFootnoteReferenceParams) error {
	_, err := q.db.Exec(ctx, createFootnoteReference, arg.FootnoteID, arg.Reference)
	return err
}

const createGrammarItem = `-- name: CreateGrammarItem :one
INSERT INTO grammar_items (story_id, line_number, grammar_point_id, text, position_start, position_end)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateGrammarItemParams struct {
	StoryID        pgtype.Int4 `json:"story_id"`
	LineNumber     pgtype.Int4 `json:"line_number"`
	GrammarPointID pgtype.Int4 `json:"grammar_point_id"`
	Text           string      `json:"text"`
	PositionStart  int32       `json:"position_start"`
	PositionEnd    int32       `json:"position_end"`
}

func (q *Queries) CreateGrammarItem(ctx context.Context, arg CreateGrammarItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, createGrammarItem,
		arg.StoryID,
		arg.LineNumber,
		arg.GrammarPointID,
		arg.Text,
		arg.PositionStart,
		arg.PositionEnd,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createVocabularyItem = `-- name: CreateVocabularyItem :one
INSERT INTO vocabulary_items (story_id, line_number, word, lexical_form, position_start, position_end)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id
`

type CreateVocabularyItemParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Word          string      `json:"word"`
	LexicalForm   string      `json:"lexical_form"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) CreateVocabularyItem(ctx context.Context, arg CreateVocabularyItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, createVocabularyItem,
		arg.StoryID,
		arg.LineNumber,
		arg.Word,
		arg.LexicalForm,
		arg.PositionStart,
		arg.PositionEnd,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const deleteFootnote = `-- name: DeleteFootnote :exec
DELETE FROM footnotes WHERE id = $1
`

func (q *Queries) DeleteFootnote(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteFootnote, id)
	return err
}

const deleteFootnoteReferences = `-- name: DeleteFootnoteReferences :exec
DELETE FROM footnote_references WHERE footnote_id = $1
`

func (q *Queries) DeleteFootnoteReferences(ctx context.Context, footnoteID int32) error {
	_, err := q.db.Exec(ctx, deleteFootnoteReferences, footnoteID)
	return err
}

const deleteGrammarItem = `-- name: DeleteGrammarItem :exec
DELETE FROM grammar_items WHERE id = $1
`

func (q *Queries) DeleteGrammarItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteGrammarItem, id)
	return err
}

const deleteGrammarItems = `-- name: DeleteGrammarItems :exec
DELETE FROM grammar_items WHERE story_id = $1 AND line_number = $2
`

type DeleteGrammarItemsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) DeleteGrammarItems(ctx context.Context, arg DeleteGrammarItemsParams) error {
	_, err := q.db.Exec(ctx, deleteGrammarItems, arg.StoryID, arg.LineNumber)
	return err
}

const deleteVocabularyItem = `-- name: DeleteVocabularyItem :exec
DELETE FROM vocabulary_items WHERE id = $1
`

func (q *Queries) DeleteVocabularyItem(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteVocabularyItem, id)
	return err
}

const deleteVocabularyItems = `-- name: DeleteVocabularyItems :exec
DELETE FROM vocabulary_items WHERE story_id = $1 AND line_number = $2
`

type DeleteVocabularyItemsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) DeleteVocabularyItems(ctx context.Context, arg DeleteVocabularyItemsParams) error {
	_, err := q.db.Exec(ctx, deleteVocabularyItems, arg.StoryID, arg.LineNumber)
	return err
}

const getAllAnnotationsForStory = `-- name: GetAllAnnotationsForStory :many
SELECT 'vocabulary' as type, v.line_number, v.word as text, v.lexical_form as extra, v.position_start, v.position_end, 0 as footnote_id
FROM vocabulary_items v
WHERE v.story_id = $1
UNION ALL
SELECT 'grammar' as type, g.line_number, g.text, '' as extra, g.position_start, g.position_end, 0 as footnote_id
FROM grammar_items g
WHERE g.story_id = $1
UNION ALL
SELECT 'footnote' as type, f.line_number, f.footnote_text as text, '' as extra, 0 as position_start, 0 as position_end, f.id as footnote_id
FROM footnotes f
WHERE f.story_id = $1
ORDER BY line_number, position_start
`

type GetAllAnnotationsForStoryRow struct {
	Type          string      `json:"type"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Text          string      `json:"text"`
	Extra         string      `json:"extra"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
	FootnoteID    int32       `json:"footnote_id"`
}

func (q *Queries) GetAllAnnotationsForStory(ctx context.Context, storyID pgtype.Int4) ([]GetAllAnnotationsForStoryRow, error) {
	rows, err := q.db.Query(ctx, getAllAnnotationsForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAnnotationsForStoryRow{}
	for rows.Next() {
		var i GetAllAnnotationsForStoryRow
		if err := rows.Scan(
			&i.Type,
			&i.LineNumber,
			&i.Text,
			&i.Extra,
			&i.PositionStart,
			&i.PositionEnd,
			&i.FootnoteID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllFootnotesForStory = `-- name: GetAllFootnotesForStory :many
SELECT f.line_number, f.id, f.footnote_text
FROM footnotes f
WHERE f.story_id = $1
ORDER BY f.line_number, f.id
`

type GetAllFootnotesForStoryRow struct {
	LineNumber   pgtype.Int4 `json:"line_number"`
	ID           int32       `json:"id"`
	FootnoteText string      `json:"footnote_text"`
}

func (q *Queries) GetAllFootnotesForStory(ctx context.Context, storyID pgtype.Int4) ([]GetAllFootnotesForStoryRow, error) {
	rows, err := q.db.Query(ctx, getAllFootnotesForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllFootnotesForStoryRow{}
	for rows.Next() {
		var i GetAllFootnotesForStoryRow
		if err := rows.Scan(&i.LineNumber, &i.ID, &i.FootnoteText); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllGrammarForStory = `-- name: GetAllGrammarForStory :many
SELECT line_number, grammar_point_id, text, position_start, position_end
FROM grammar_items
WHERE story_id = $1
ORDER BY line_number, position_start
`

type GetAllGrammarForStoryRow struct {
	LineNumber     pgtype.Int4 `json:"line_number"`
	GrammarPointID pgtype.Int4 `json:"grammar_point_id"`
	Text           string      `json:"text"`
	PositionStart  int32       `json:"position_start"`
	PositionEnd    int32       `json:"position_end"`
}

func (q *Queries) GetAllGrammarForStory(ctx context.Context, storyID pgtype.Int4) ([]GetAllGrammarForStoryRow, error) {
	rows, err := q.db.Query(ctx, getAllGrammarForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllGrammarForStoryRow{}
	for rows.Next() {
		var i GetAllGrammarForStoryRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.GrammarPointID,
			&i.Text,
			&i.PositionStart,
			&i.PositionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllVocabularyForStory = `-- name: GetAllVocabularyForStory :many
SELECT line_number, word, lexical_form, position_start, position_end
FROM vocabulary_items
WHERE story_id = $1
ORDER BY line_number, position_start
`

type GetAllVocabularyForStoryRow struct {
	LineNumber    pgtype.Int4 `json:"line_number"`
	Word          string      `json:"word"`
	LexicalForm   string      `json:"lexical_form"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) GetAllVocabularyForStory(ctx context.Context, storyID pgtype.Int4) ([]GetAllVocabularyForStoryRow, error) {
	rows, err := q.db.Query(ctx, getAllVocabularyForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllVocabularyForStoryRow{}
	for rows.Next() {
		var i GetAllVocabularyForStoryRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.Word,
			&i.LexicalForm,
			&i.PositionStart,
			&i.PositionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootnoteReferences = `-- name: GetFootnoteReferences :many
SELECT reference
FROM footnote_references
WHERE footnote_id = $1
`

func (q *Queries) GetFootnoteReferences(ctx context.Context, footnoteID int32) ([]string, error) {
	rows, err := q.db.Query(ctx, getFootnoteReferences, footnoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var reference string
		if err := rows.Scan(&reference); err != nil {
			return nil, err
		}
		items = append(items, reference)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFootnotes = `-- name: GetFootnotes :many
SELECT f.id, f.story_id, f.line_number, f.footnote_text
FROM footnotes f
WHERE f.story_id = $1 AND f.line_number = $2
`

type GetFootnotesParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) GetFootnotes(ctx context.Context, arg GetFootnotesParams) ([]Footnote, error) {
	rows, err := q.db.Query(ctx, getFootnotes, arg.StoryID, arg.LineNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Footnote{}
	for rows.Next() {
		var i Footnote
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.LineNumber,
			&i.FootnoteText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGrammarItems = `-- name: GetGrammarItems :many
SELECT id, story_id, line_number, grammar_point_id, text, position_start, position_end
FROM grammar_items
WHERE story_id = $1 AND line_number = $2
ORDER BY position_start
`

type GetGrammarItemsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) GetGrammarItems(ctx context.Context, arg GetGrammarItemsParams) ([]GrammarItem, error) {
	rows, err := q.db.Query(ctx, getGrammarItems, arg.StoryID, arg.LineNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GrammarItem{}
	for rows.Next() {
		var i GrammarItem
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.LineNumber,
			&i.GrammarPointID,
			&i.Text,
			&i.PositionStart,
			&i.PositionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryFootnotesWithReferences = `-- name: GetStoryFootnotesWithReferences :many
SELECT f.id, f.line_number, f.footnote_text, array_agg(fr.reference ORDER BY fr.reference) as references
FROM footnotes f
LEFT JOIN footnote_references fr ON f.id = fr.footnote_id
WHERE f.story_id = $1
GROUP BY f.id, f.line_number, f.footnote_text
ORDER BY f.line_number, f.id
`

type GetStoryFootnotesWithReferencesRow struct {
	ID           int32       `json:"id"`
	LineNumber   pgtype.Int4 `json:"line_number"`
	FootnoteText string      `json:"footnote_text"`
	References   interface{} `json:"references"`
}

func (q *Queries) GetStoryFootnotesWithReferences(ctx context.Context, storyID pgtype.Int4) ([]GetStoryFootnotesWithReferencesRow, error) {
	rows, err := q.db.Query(ctx, getStoryFootnotesWithReferences, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoryFootnotesWithReferencesRow{}
	for rows.Next() {
		var i GetStoryFootnotesWithReferencesRow
		if err := rows.Scan(
			&i.ID,
			&i.LineNumber,
			&i.FootnoteText,
			&i.References,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVocabularyItems = `-- name: GetVocabularyItems :many
SELECT id, story_id, line_number, word, lexical_form, position_start, position_end
FROM vocabulary_items
WHERE story_id = $1 AND line_number = $2
ORDER BY position_start
`

type GetVocabularyItemsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) GetVocabularyItems(ctx context.Context, arg GetVocabularyItemsParams) ([]VocabularyItem, error) {
	rows, err := q.db.Query(ctx, getVocabularyItems, arg.StoryID, arg.LineNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VocabularyItem{}
	for rows.Next() {
		var i VocabularyItem
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.LineNumber,
			&i.Word,
			&i.LexicalForm,
			&i.PositionStart,
			&i.PositionEnd,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFootnote = `-- name: UpdateFootnote :exec
UPDATE footnotes
SET footnote_text = $3
WHERE id = $1 AND story_id = $2
`

type UpdateFootnoteParams struct {
	ID           int32       `json:"id"`
	StoryID      pgtype.Int4 `json:"story_id"`
	FootnoteText string      `json:"footnote_text"`
}

func (q *Queries) UpdateFootnote(ctx context.Context, arg UpdateFootnoteParams) error {
	_, err := q.db.Exec(ctx, updateFootnote, arg.ID, arg.StoryID, arg.FootnoteText)
	return err
}

const updateGrammarByPosition = `-- name: UpdateGrammarByPosition :exec
UPDATE grammar_items
SET grammar_point_id = $5, text = $6, position_start = $7, position_end = $8
WHERE story_id = $1 AND line_number = $2 AND position_start = $3 AND position_end = $4
`

type UpdateGrammarByPositionParams struct {
	StoryID         pgtype.Int4 `json:"story_id"`
	LineNumber      pgtype.Int4 `json:"line_number"`
	PositionStart   int32       `json:"position_start"`
	PositionEnd     int32       `json:"position_end"`
	GrammarPointID  pgtype.Int4 `json:"grammar_point_id"`
	Text            string      `json:"text"`
	PositionStart_2 int32       `json:"position_start_2"`
	PositionEnd_2   int32       `json:"position_end_2"`
}

func (q *Queries) UpdateGrammarByPosition(ctx context.Context, arg UpdateGrammarByPositionParams) error {
	_, err := q.db.Exec(ctx, updateGrammarByPosition,
		arg.StoryID,
		arg.LineNumber,
		arg.PositionStart,
		arg.PositionEnd,
		arg.GrammarPointID,
		arg.Text,
		arg.PositionStart_2,
		arg.PositionEnd_2,
	)
	return err
}

const updateVocabularyByPosition = `-- name: UpdateVocabularyByPosition :exec
UPDATE vocabulary_items
SET word = $5, lexical_form = $6, position_start = $7, position_end = $8
WHERE story_id = $1 AND line_number = $2 AND position_start = $3 AND position_end = $4
`

type UpdateVocabularyByPositionParams struct {
	StoryID         pgtype.Int4 `json:"story_id"`
	LineNumber      pgtype.Int4 `json:"line_number"`
	PositionStart   int32       `json:"position_start"`
	PositionEnd     int32       `json:"position_end"`
	Word            string      `json:"word"`
	LexicalForm     string      `json:"lexical_form"`
	PositionStart_2 int32       `json:"position_start_2"`
	PositionEnd_2   int32       `json:"position_end_2"`
}

func (q *Queries) UpdateVocabularyByPosition(ctx context.Context, arg UpdateVocabularyByPositionParams) error {
	_, err := q.db.Exec(ctx, updateVocabularyByPosition,
		arg.StoryID,
		arg.LineNumber,
		arg.PositionStart,
		arg.PositionEnd,
		arg.Word,
		arg.LexicalForm,
		arg.PositionStart_2,
		arg.PositionEnd_2,
	)
	return err
}

const updateVocabularyByWord = `-- name: UpdateVocabularyByWord :exec
UPDATE vocabulary_items
SET lexical_form = $4
WHERE story_id = $1 AND line_number = $2 AND word = $3
`

type UpdateVocabularyByWordParams struct {
	StoryID     pgtype.Int4 `json:"story_id"`
	LineNumber  pgtype.Int4 `json:"line_number"`
	Word        string      `json:"word"`
	LexicalForm string      `json:"lexical_form"`
}

func (q *Queries) UpdateVocabularyByWord(ctx context.Context, arg UpdateVocabularyByWordParams) error {
	_, err := q.db.Exec(ctx, updateVocabularyByWord,
		arg.StoryID,
		arg.LineNumber,
		arg.Word,
		arg.LexicalForm,
	)
	return err
}

const updateVocabularyItem = `-- name: UpdateVocabularyItem :exec
UPDATE vocabulary_items
SET word = $2, lexical_form = $3, position_start = $4, position_end = $5
WHERE id = $1
`

type UpdateVocabularyItemParams struct {
	ID            int32  `json:"id"`
	Word          string `json:"word"`
	LexicalForm   string `json:"lexical_form"`
	PositionStart int32  `json:"position_start"`
	PositionEnd   int32  `json:"position_end"`
}

func (q *Queries) UpdateVocabularyItem(ctx context.Context, arg UpdateVocabularyItemParams) error {
	_, err := q.db.Exec(ctx, updateVocabularyItem,
		arg.ID,
		arg.Word,
		arg.LexicalForm,
		arg.PositionStart,
		arg.PositionEnd,
	)
	return err
}
