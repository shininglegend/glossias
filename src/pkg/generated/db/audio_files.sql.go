// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: audio_files.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAudioFile = `-- name: CreateAudioFile :one

INSERT INTO line_audio_files (story_id, line_number, file_path, file_bucket, label)
VALUES ($1, $2, $3, $4, $5)
RETURNING audio_file_id, story_id, line_number, file_path, file_bucket, label, created_at
`

type CreateAudioFileParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
	FilePath   string      `json:"file_path"`
	FileBucket string      `json:"file_bucket"`
	Label      string      `json:"label"`
}

// Audio files management queries
func (q *Queries) CreateAudioFile(ctx context.Context, arg CreateAudioFileParams) (LineAudioFile, error) {
	row := q.db.QueryRow(ctx, createAudioFile,
		arg.StoryID,
		arg.LineNumber,
		arg.FilePath,
		arg.FileBucket,
		arg.Label,
	)
	var i LineAudioFile
	err := row.Scan(
		&i.AudioFileID,
		&i.StoryID,
		&i.LineNumber,
		&i.FilePath,
		&i.FileBucket,
		&i.Label,
		&i.CreatedAt,
	)
	return i, err
}

const deleteAudioFile = `-- name: DeleteAudioFile :exec
DELETE FROM line_audio_files
WHERE audio_file_id = $1
`

func (q *Queries) DeleteAudioFile(ctx context.Context, audioFileID int32) error {
	_, err := q.db.Exec(ctx, deleteAudioFile, audioFileID)
	return err
}

const deleteLineAudioFiles = `-- name: DeleteLineAudioFiles :exec
DELETE FROM line_audio_files
WHERE story_id = $1 AND line_number = $2
`

type DeleteLineAudioFilesParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) DeleteLineAudioFiles(ctx context.Context, arg DeleteLineAudioFilesParams) error {
	_, err := q.db.Exec(ctx, deleteLineAudioFiles, arg.StoryID, arg.LineNumber)
	return err
}

const deleteStoryAudioFiles = `-- name: DeleteStoryAudioFiles :exec
DELETE FROM line_audio_files
WHERE story_id = $1
`

func (q *Queries) DeleteStoryAudioFiles(ctx context.Context, storyID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteStoryAudioFiles, storyID)
	return err
}

const deleteStoryAudioFilesByLabel = `-- name: DeleteStoryAudioFilesByLabel :exec
DELETE FROM line_audio_files
WHERE story_id = $1 AND label = $2
`

type DeleteStoryAudioFilesByLabelParams struct {
	StoryID pgtype.Int4 `json:"story_id"`
	Label   string      `json:"label"`
}

func (q *Queries) DeleteStoryAudioFilesByLabel(ctx context.Context, arg DeleteStoryAudioFilesByLabelParams) error {
	_, err := q.db.Exec(ctx, deleteStoryAudioFilesByLabel, arg.StoryID, arg.Label)
	return err
}

const getAllStoryAudioFiles = `-- name: GetAllStoryAudioFiles :many
SELECT audio_file_id, story_id, line_number, file_path, file_bucket, label, created_at
FROM line_audio_files
WHERE story_id = $1
ORDER BY line_number, label, created_at
`

func (q *Queries) GetAllStoryAudioFiles(ctx context.Context, storyID pgtype.Int4) ([]LineAudioFile, error) {
	rows, err := q.db.Query(ctx, getAllStoryAudioFiles, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineAudioFile{}
	for rows.Next() {
		var i LineAudioFile
		if err := rows.Scan(
			&i.AudioFileID,
			&i.StoryID,
			&i.LineNumber,
			&i.FilePath,
			&i.FileBucket,
			&i.Label,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAudioFile = `-- name: GetAudioFile :one
SELECT audio_file_id, story_id, line_number, file_path, file_bucket, label, created_at
FROM line_audio_files
WHERE audio_file_id = $1
`

func (q *Queries) GetAudioFile(ctx context.Context, audioFileID int32) (LineAudioFile, error) {
	row := q.db.QueryRow(ctx, getAudioFile, audioFileID)
	var i LineAudioFile
	err := row.Scan(
		&i.AudioFileID,
		&i.StoryID,
		&i.LineNumber,
		&i.FilePath,
		&i.FileBucket,
		&i.Label,
		&i.CreatedAt,
	)
	return i, err
}

const getAudioFilesByLabel = `-- name: GetAudioFilesByLabel :many
SELECT audio_file_id, story_id, line_number, file_path, file_bucket, label, created_at
FROM line_audio_files
WHERE label = $1
ORDER BY story_id, line_number
`

func (q *Queries) GetAudioFilesByLabel(ctx context.Context, label string) ([]LineAudioFile, error) {
	rows, err := q.db.Query(ctx, getAudioFilesByLabel, label)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineAudioFile{}
	for rows.Next() {
		var i LineAudioFile
		if err := rows.Scan(
			&i.AudioFileID,
			&i.StoryID,
			&i.LineNumber,
			&i.FilePath,
			&i.FileBucket,
			&i.Label,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLineAudioFiles = `-- name: GetLineAudioFiles :many
SELECT audio_file_id, story_id, line_number, file_path, file_bucket, label, created_at
FROM line_audio_files
WHERE story_id = $1 AND line_number = $2
ORDER BY label, created_at
`

type GetLineAudioFilesParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) GetLineAudioFiles(ctx context.Context, arg GetLineAudioFilesParams) ([]LineAudioFile, error) {
	rows, err := q.db.Query(ctx, getLineAudioFiles, arg.StoryID, arg.LineNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineAudioFile{}
	for rows.Next() {
		var i LineAudioFile
		if err := rows.Scan(
			&i.AudioFileID,
			&i.StoryID,
			&i.LineNumber,
			&i.FilePath,
			&i.FileBucket,
			&i.Label,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryAudioFilesByLabel = `-- name: GetStoryAudioFilesByLabel :many
SELECT laf.audio_file_id, laf.story_id, laf.line_number, laf.file_path, laf.file_bucket, laf.label, laf.created_at
FROM line_audio_files laf
WHERE laf.story_id = $1 AND laf.label = $2
ORDER BY laf.line_number
`

type GetStoryAudioFilesByLabelParams struct {
	StoryID pgtype.Int4 `json:"story_id"`
	Label   string      `json:"label"`
}

func (q *Queries) GetStoryAudioFilesByLabel(ctx context.Context, arg GetStoryAudioFilesByLabelParams) ([]LineAudioFile, error) {
	rows, err := q.db.Query(ctx, getStoryAudioFilesByLabel, arg.StoryID, arg.Label)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineAudioFile{}
	for rows.Next() {
		var i LineAudioFile
		if err := rows.Scan(
			&i.AudioFileID,
			&i.StoryID,
			&i.LineNumber,
			&i.FilePath,
			&i.FileBucket,
			&i.Label,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAudioFile = `-- name: UpdateAudioFile :one
UPDATE line_audio_files
SET file_path = $3, file_bucket = $4, label = $5
WHERE audio_file_id = $1 AND story_id = $2
RETURNING audio_file_id, story_id, line_number, file_path, file_bucket, label, created_at
`

type UpdateAudioFileParams struct {
	AudioFileID int32       `json:"audio_file_id"`
	StoryID     pgtype.Int4 `json:"story_id"`
	FilePath    string      `json:"file_path"`
	FileBucket  string      `json:"file_bucket"`
	Label       string      `json:"label"`
}

func (q *Queries) UpdateAudioFile(ctx context.Context, arg UpdateAudioFileParams) (LineAudioFile, error) {
	row := q.db.QueryRow(ctx, updateAudioFile,
		arg.AudioFileID,
		arg.StoryID,
		arg.FilePath,
		arg.FileBucket,
		arg.Label,
	)
	var i LineAudioFile
	err := row.Scan(
		&i.AudioFileID,
		&i.StoryID,
		&i.LineNumber,
		&i.FilePath,
		&i.FileBucket,
		&i.Label,
		&i.CreatedAt,
	)
	return i, err
}
