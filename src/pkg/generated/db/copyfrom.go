// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: copyfrom.go

package db

import (
	"context"
)

// iteratorForBulkCreateAudioFiles implements pgx.CopyFromSource.
type iteratorForBulkCreateAudioFiles struct {
	rows                 []BulkCreateAudioFilesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateAudioFiles) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateAudioFiles) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].StoryID,
		r.rows[0].LineNumber,
		r.rows[0].FilePath,
		r.rows[0].FileBucket,
		r.rows[0].Label,
	}, nil
}

func (r iteratorForBulkCreateAudioFiles) Err() error {
	return nil
}

func (q *Queries) BulkCreateAudioFiles(ctx context.Context, arg []BulkCreateAudioFilesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"line_audio_files"}, []string{"story_id", "line_number", "file_path", "file_bucket", "label"}, &iteratorForBulkCreateAudioFiles{rows: arg})
}

// iteratorForBulkCreateGrammarItems implements pgx.CopyFromSource.
type iteratorForBulkCreateGrammarItems struct {
	rows                 []BulkCreateGrammarItemsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateGrammarItems) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateGrammarItems) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].StoryID,
		r.rows[0].LineNumber,
		r.rows[0].GrammarPointID,
		r.rows[0].Text,
		r.rows[0].PositionStart,
		r.rows[0].PositionEnd,
	}, nil
}

func (r iteratorForBulkCreateGrammarItems) Err() error {
	return nil
}

func (q *Queries) BulkCreateGrammarItems(ctx context.Context, arg []BulkCreateGrammarItemsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"grammar_items"}, []string{"story_id", "line_number", "grammar_point_id", "text", "position_start", "position_end"}, &iteratorForBulkCreateGrammarItems{rows: arg})
}

// iteratorForBulkCreateStoryGrammarPoints implements pgx.CopyFromSource.
type iteratorForBulkCreateStoryGrammarPoints struct {
	rows                 []BulkCreateStoryGrammarPointsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateStoryGrammarPoints) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateStoryGrammarPoints) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].StoryID,
		r.rows[0].GrammarPointID,
	}, nil
}

func (r iteratorForBulkCreateStoryGrammarPoints) Err() error {
	return nil
}

func (q *Queries) BulkCreateStoryGrammarPoints(ctx context.Context, arg []BulkCreateStoryGrammarPointsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"story_grammar_points"}, []string{"story_id", "grammar_point_id"}, &iteratorForBulkCreateStoryGrammarPoints{rows: arg})
}

// iteratorForBulkCreateStoryLines implements pgx.CopyFromSource.
type iteratorForBulkCreateStoryLines struct {
	rows                 []BulkCreateStoryLinesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateStoryLines) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateStoryLines) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].StoryID,
		r.rows[0].LineNumber,
		r.rows[0].Text,
		r.rows[0].EnglishTranslation,
	}, nil
}

func (r iteratorForBulkCreateStoryLines) Err() error {
	return nil
}

func (q *Queries) BulkCreateStoryLines(ctx context.Context, arg []BulkCreateStoryLinesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"story_lines"}, []string{"story_id", "line_number", "text", "english_translation"}, &iteratorForBulkCreateStoryLines{rows: arg})
}

// iteratorForBulkCreateVocabularyItems implements pgx.CopyFromSource.
type iteratorForBulkCreateVocabularyItems struct {
	rows                 []BulkCreateVocabularyItemsParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkCreateVocabularyItems) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkCreateVocabularyItems) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].StoryID,
		r.rows[0].LineNumber,
		r.rows[0].Word,
		r.rows[0].LexicalForm,
		r.rows[0].PositionStart,
		r.rows[0].PositionEnd,
	}, nil
}

func (r iteratorForBulkCreateVocabularyItems) Err() error {
	return nil
}

func (q *Queries) BulkCreateVocabularyItems(ctx context.Context, arg []BulkCreateVocabularyItemsParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"vocabulary_items"}, []string{"story_id", "line_number", "word", "lexical_form", "position_start", "position_end"}, &iteratorForBulkCreateVocabularyItems{rows: arg})
}
