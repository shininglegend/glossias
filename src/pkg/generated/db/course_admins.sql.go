// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: course_admins.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCourseAdmin = `-- name: AddCourseAdmin :one

INSERT INTO course_admins (course_id, user_id)
VALUES ($1, $2)
RETURNING course_id, user_id, assigned_at
`

type AddCourseAdminParams struct {
	CourseID int32  `json:"course_id"`
	UserID   string `json:"user_id"`
}

// Course admin management queries
func (q *Queries) AddCourseAdmin(ctx context.Context, arg AddCourseAdminParams) (CourseAdmin, error) {
	row := q.db.QueryRow(ctx, addCourseAdmin, arg.CourseID, arg.UserID)
	var i CourseAdmin
	err := row.Scan(&i.CourseID, &i.UserID, &i.AssignedAt)
	return i, err
}

const getCourseAdmins = `-- name: GetCourseAdmins :many
SELECT ca.course_id, ca.user_id, ca.assigned_at, u.email, u.name
FROM course_admins ca
JOIN users u ON ca.user_id = u.user_id
WHERE ca.course_id = $1
ORDER BY ca.assigned_at
`

type GetCourseAdminsRow struct {
	CourseID   int32            `json:"course_id"`
	UserID     string           `json:"user_id"`
	AssignedAt pgtype.Timestamp `json:"assigned_at"`
	Email      string           `json:"email"`
	Name       string           `json:"name"`
}

func (q *Queries) GetCourseAdmins(ctx context.Context, courseID int32) ([]GetCourseAdminsRow, error) {
	rows, err := q.db.Query(ctx, getCourseAdmins, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCourseAdminsRow{}
	for rows.Next() {
		var i GetCourseAdminsRow
		if err := rows.Scan(
			&i.CourseID,
			&i.UserID,
			&i.AssignedAt,
			&i.Email,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCourseAdminRights = `-- name: GetUserCourseAdminRights :many
SELECT ca.course_id, ca.assigned_at, c.course_number, c.name as course_name
FROM course_admins ca
JOIN courses c ON ca.course_id = c.course_id
WHERE ca.user_id = $1
ORDER BY c.course_number
`

type GetUserCourseAdminRightsRow struct {
	CourseID     int32            `json:"course_id"`
	AssignedAt   pgtype.Timestamp `json:"assigned_at"`
	CourseNumber string           `json:"course_number"`
	CourseName   string           `json:"course_name"`
}

func (q *Queries) GetUserCourseAdminRights(ctx context.Context, userID string) ([]GetUserCourseAdminRightsRow, error) {
	rows, err := q.db.Query(ctx, getUserCourseAdminRights, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCourseAdminRightsRow{}
	for rows.Next() {
		var i GetUserCourseAdminRightsRow
		if err := rows.Scan(
			&i.CourseID,
			&i.AssignedAt,
			&i.CourseNumber,
			&i.CourseName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserAdminOfAnyCourse = `-- name: IsUserAdminOfAnyCourse :one
SELECT EXISTS(
    SELECT 1 FROM course_admins
    WHERE user_id = $1
) as is_admin
`

func (q *Queries) IsUserAdminOfAnyCourse(ctx context.Context, userID string) (bool, error) {
	row := q.db.QueryRow(ctx, isUserAdminOfAnyCourse, userID)
	var is_admin bool
	err := row.Scan(&is_admin)
	return is_admin, err
}

const isUserCourseAdmin = `-- name: IsUserCourseAdmin :one
SELECT EXISTS(
    SELECT 1 FROM course_admins
    WHERE course_id = $1 AND user_id = $2
) as is_admin
`

type IsUserCourseAdminParams struct {
	CourseID int32  `json:"course_id"`
	UserID   string `json:"user_id"`
}

func (q *Queries) IsUserCourseAdmin(ctx context.Context, arg IsUserCourseAdminParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserCourseAdmin, arg.CourseID, arg.UserID)
	var is_admin bool
	err := row.Scan(&is_admin)
	return is_admin, err
}

const removeCourseAdmin = `-- name: RemoveCourseAdmin :exec
DELETE FROM course_admins
WHERE course_id = $1 AND user_id = $2
`

type RemoveCourseAdminParams struct {
	CourseID int32  `json:"course_id"`
	UserID   string `json:"user_id"`
}

func (q *Queries) RemoveCourseAdmin(ctx context.Context, arg RemoveCourseAdminParams) error {
	_, err := q.db.Exec(ctx, removeCourseAdmin, arg.CourseID, arg.UserID)
	return err
}
