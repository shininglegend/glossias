// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: course_users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMultiUsersToCourse = `-- name: AddMultiUsersToCourse :exec
INSERT INTO course_users (course_id, user_id, enrolled_at)
SELECT $1, unnest($2::text[]), CURRENT_TIMESTAMP
ON CONFLICT (course_id, user_id) DO NOTHING
`

type AddMultiUsersToCourseParams struct {
	CourseID int32    `json:"course_id"`
	Column2  []string `json:"column_2"`
}

func (q *Queries) AddMultiUsersToCourse(ctx context.Context, arg AddMultiUsersToCourseParams) error {
	_, err := q.db.Exec(ctx, addMultiUsersToCourse, arg.CourseID, arg.Column2)
	return err
}

const addUserToCourse = `-- name: AddUserToCourse :exec
INSERT INTO course_users (course_id, user_id, enrolled_at, status)
VALUES ($1, $2, CURRENT_TIMESTAMP, COALESCE($3, 'active'))
`

type AddUserToCourseParams struct {
	CourseID int32       `json:"course_id"`
	UserID   string      `json:"user_id"`
	Column3  interface{} `json:"column_3"`
}

func (q *Queries) AddUserToCourse(ctx context.Context, arg AddUserToCourseParams) error {
	_, err := q.db.Exec(ctx, addUserToCourse, arg.CourseID, arg.UserID, arg.Column3)
	return err
}

const bulkUpdateCourseUserStatus = `-- name: BulkUpdateCourseUserStatus :exec
UPDATE course_users
SET status = $3
WHERE course_id = $1 AND user_id = ANY($2::text[])
`

type BulkUpdateCourseUserStatusParams struct {
	CourseID int32       `json:"course_id"`
	Column2  []string    `json:"column_2"`
	Status   pgtype.Text `json:"status"`
}

func (q *Queries) BulkUpdateCourseUserStatus(ctx context.Context, arg BulkUpdateCourseUserStatusParams) error {
	_, err := q.db.Exec(ctx, bulkUpdateCourseUserStatus, arg.CourseID, arg.Column2, arg.Status)
	return err
}

const canUserAccessCourse = `-- name: CanUserAccessCourse :one
SELECT EXISTS(
    SELECT 1 FROM users u
    LEFT JOIN course_admins ca ON u.user_id = ca.user_id
    LEFT JOIN course_users cu ON u.user_id = cu.user_id
    WHERE u.user_id = $1
    AND (u.is_super_admin = true OR ca.course_id = $2 OR cu.course_id = $2)
) as can_access
`

type CanUserAccessCourseParams struct {
	UserID   string `json:"user_id"`
	CourseID int32  `json:"course_id"`
}

func (q *Queries) CanUserAccessCourse(ctx context.Context, arg CanUserAccessCourseParams) (bool, error) {
	row := q.db.QueryRow(ctx, canUserAccessCourse, arg.UserID, arg.CourseID)
	var can_access bool
	err := row.Scan(&can_access)
	return can_access, err
}

const deleteAllUsersFromCourse = `-- name: DeleteAllUsersFromCourse :exec
DELETE FROM course_users
WHERE course_id = $1
`

func (q *Queries) DeleteAllUsersFromCourse(ctx context.Context, courseID int32) error {
	_, err := q.db.Exec(ctx, deleteAllUsersFromCourse, courseID)
	return err
}

const getCoursesForUser = `-- name: GetCoursesForUser :many
SELECT c.course_id, c.course_number, c.name, c.description, cu.enrolled_at, cu.status
FROM courses c
JOIN course_users cu ON c.course_id = cu.course_id
WHERE cu.user_id = $1
ORDER BY c.course_number
`

type GetCoursesForUserRow struct {
	CourseID     int32            `json:"course_id"`
	CourseNumber string           `json:"course_number"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	EnrolledAt   pgtype.Timestamp `json:"enrolled_at"`
	Status       pgtype.Text      `json:"status"`
}

func (q *Queries) GetCoursesForUser(ctx context.Context, userID string) ([]GetCoursesForUserRow, error) {
	rows, err := q.db.Query(ctx, getCoursesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoursesForUserRow{}
	for rows.Next() {
		var i GetCoursesForUserRow
		if err := rows.Scan(
			&i.CourseID,
			&i.CourseNumber,
			&i.Name,
			&i.Description,
			&i.EnrolledAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoursesForUserByStatus = `-- name: GetCoursesForUserByStatus :many
SELECT c.course_id, c.course_number, c.name, c.description, cu.enrolled_at, cu.status
FROM courses c
JOIN course_users cu ON c.course_id = cu.course_id
WHERE cu.user_id = $1 AND cu.status = $2
ORDER BY c.course_number
`

type GetCoursesForUserByStatusParams struct {
	UserID string      `json:"user_id"`
	Status pgtype.Text `json:"status"`
}

type GetCoursesForUserByStatusRow struct {
	CourseID     int32            `json:"course_id"`
	CourseNumber string           `json:"course_number"`
	Name         string           `json:"name"`
	Description  pgtype.Text      `json:"description"`
	EnrolledAt   pgtype.Timestamp `json:"enrolled_at"`
	Status       pgtype.Text      `json:"status"`
}

func (q *Queries) GetCoursesForUserByStatus(ctx context.Context, arg GetCoursesForUserByStatusParams) ([]GetCoursesForUserByStatusRow, error) {
	rows, err := q.db.Query(ctx, getCoursesForUserByStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCoursesForUserByStatusRow{}
	for rows.Next() {
		var i GetCoursesForUserByStatusRow
		if err := rows.Scan(
			&i.CourseID,
			&i.CourseNumber,
			&i.Name,
			&i.Description,
			&i.EnrolledAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersForCourse = `-- name: GetUsersForCourse :many
SELECT u.user_id, u.email, u.name, cu.enrolled_at, cu.status
FROM users u
JOIN course_users cu ON u.user_id = cu.user_id
WHERE cu.course_id = $1
ORDER BY u.name
`

type GetUsersForCourseRow struct {
	UserID     string           `json:"user_id"`
	Email      string           `json:"email"`
	Name       string           `json:"name"`
	EnrolledAt pgtype.Timestamp `json:"enrolled_at"`
	Status     pgtype.Text      `json:"status"`
}

func (q *Queries) GetUsersForCourse(ctx context.Context, courseID int32) ([]GetUsersForCourseRow, error) {
	rows, err := q.db.Query(ctx, getUsersForCourse, courseID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersForCourseRow{}
	for rows.Next() {
		var i GetUsersForCourseRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Name,
			&i.EnrolledAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromCourse = `-- name: RemoveUserFromCourse :exec
DELETE FROM course_users
WHERE course_id = $1 AND user_id = $2
`

type RemoveUserFromCourseParams struct {
	CourseID int32  `json:"course_id"`
	UserID   string `json:"user_id"`
}

func (q *Queries) RemoveUserFromCourse(ctx context.Context, arg RemoveUserFromCourseParams) error {
	_, err := q.db.Exec(ctx, removeUserFromCourse, arg.CourseID, arg.UserID)
	return err
}

const updateCourseUserStatus = `-- name: UpdateCourseUserStatus :exec
UPDATE course_users
SET status = $3
WHERE course_id = $1 AND user_id = $2
`

type UpdateCourseUserStatusParams struct {
	CourseID int32       `json:"course_id"`
	UserID   string      `json:"user_id"`
	Status   pgtype.Text `json:"status"`
}

func (q *Queries) UpdateCourseUserStatus(ctx context.Context, arg UpdateCourseUserStatusParams) error {
	_, err := q.db.Exec(ctx, updateCourseUserStatus, arg.CourseID, arg.UserID, arg.Status)
	return err
}
