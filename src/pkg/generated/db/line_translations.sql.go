// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: line_translations.sql

package db

import (
	"context"
)

const deleteLineTranslation = `-- name: DeleteLineTranslation :exec
DELETE FROM line_translations
WHERE story_id = $1 AND line_number = $2 AND language_code = $3
`

type DeleteLineTranslationParams struct {
	StoryID      int32  `json:"story_id"`
	LineNumber   int32  `json:"line_number"`
	LanguageCode string `json:"language_code"`
}

func (q *Queries) DeleteLineTranslation(ctx context.Context, arg DeleteLineTranslationParams) error {
	_, err := q.db.Exec(ctx, deleteLineTranslation, arg.StoryID, arg.LineNumber, arg.LanguageCode)
	return err
}

const getAllTranslationsForStory = `-- name: GetAllTranslationsForStory :many
SELECT story_id, line_number, language_code, translation_text
FROM line_translations
WHERE story_id = $1
ORDER BY line_number, language_code
`

func (q *Queries) GetAllTranslationsForStory(ctx context.Context, storyID int32) ([]LineTranslation, error) {
	rows, err := q.db.Query(ctx, getAllTranslationsForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineTranslation{}
	for rows.Next() {
		var i LineTranslation
		if err := rows.Scan(
			&i.StoryID,
			&i.LineNumber,
			&i.LanguageCode,
			&i.TranslationText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLineTranslation = `-- name: GetLineTranslation :one
SELECT translation_text
FROM line_translations
WHERE story_id = $1 AND line_number = $2 AND language_code = $3
`

type GetLineTranslationParams struct {
	StoryID      int32  `json:"story_id"`
	LineNumber   int32  `json:"line_number"`
	LanguageCode string `json:"language_code"`
}

func (q *Queries) GetLineTranslation(ctx context.Context, arg GetLineTranslationParams) (string, error) {
	row := q.db.QueryRow(ctx, getLineTranslation, arg.StoryID, arg.LineNumber, arg.LanguageCode)
	var translation_text string
	err := row.Scan(&translation_text)
	return translation_text, err
}

const getLineTranslations = `-- name: GetLineTranslations :many

SELECT story_id, line_number, language_code, translation_text
FROM line_translations
WHERE story_id = $1 AND line_number = $2
ORDER BY language_code
`

type GetLineTranslationsParams struct {
	StoryID    int32 `json:"story_id"`
	LineNumber int32 `json:"line_number"`
}

// Line translations management queries
func (q *Queries) GetLineTranslations(ctx context.Context, arg GetLineTranslationsParams) ([]LineTranslation, error) {
	rows, err := q.db.Query(ctx, getLineTranslations, arg.StoryID, arg.LineNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LineTranslation{}
	for rows.Next() {
		var i LineTranslation
		if err := rows.Scan(
			&i.StoryID,
			&i.LineNumber,
			&i.LanguageCode,
			&i.TranslationText,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationsByLanguage = `-- name: GetTranslationsByLanguage :many
SELECT story_id, line_number, translation_text
FROM line_translations
WHERE story_id = $1 AND language_code = $2
ORDER BY line_number
`

type GetTranslationsByLanguageParams struct {
	StoryID      int32  `json:"story_id"`
	LanguageCode string `json:"language_code"`
}

type GetTranslationsByLanguageRow struct {
	StoryID         int32  `json:"story_id"`
	LineNumber      int32  `json:"line_number"`
	TranslationText string `json:"translation_text"`
}

func (q *Queries) GetTranslationsByLanguage(ctx context.Context, arg GetTranslationsByLanguageParams) ([]GetTranslationsByLanguageRow, error) {
	rows, err := q.db.Query(ctx, getTranslationsByLanguage, arg.StoryID, arg.LanguageCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTranslationsByLanguageRow{}
	for rows.Next() {
		var i GetTranslationsByLanguageRow
		if err := rows.Scan(&i.StoryID, &i.LineNumber, &i.TranslationText); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertLineTranslation = `-- name: UpsertLineTranslation :exec
INSERT INTO line_translations (story_id, line_number, language_code, translation_text)
VALUES ($1, $2, $3, $4)
ON CONFLICT (story_id, line_number, language_code)
DO UPDATE SET translation_text = EXCLUDED.translation_text
`

type UpsertLineTranslationParams struct {
	StoryID         int32  `json:"story_id"`
	LineNumber      int32  `json:"line_number"`
	LanguageCode    string `json:"language_code"`
	TranslationText string `json:"translation_text"`
}

func (q *Queries) UpsertLineTranslation(ctx context.Context, arg UpsertLineTranslationParams) error {
	_, err := q.db.Exec(ctx, upsertLineTranslation,
		arg.StoryID,
		arg.LineNumber,
		arg.LanguageCode,
		arg.TranslationText,
	)
	return err
}
