// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scores.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllUsersStoryGrammarSummary = `-- name: GetAllUsersStoryGrammarSummary :many
SELECT
    gs.user_id,
    u.name as user_name,
    u.email,
    COUNT(*) as total_attempts,
    COUNT(CASE WHEN gs.correct = true THEN 1 END) as correct_answers,
    COUNT(CASE WHEN gs.correct = false THEN 1 END) as incorrect_answers
FROM grammar_scores gs
JOIN users u ON gs.user_id = u.user_id
WHERE gs.story_id = $1
GROUP BY gs.user_id, u.name, u.email
ORDER BY u.name
`

type GetAllUsersStoryGrammarSummaryRow struct {
	UserID           string `json:"user_id"`
	UserName         string `json:"user_name"`
	Email            string `json:"email"`
	TotalAttempts    int64  `json:"total_attempts"`
	CorrectAnswers   int64  `json:"correct_answers"`
	IncorrectAnswers int64  `json:"incorrect_answers"`
}

func (q *Queries) GetAllUsersStoryGrammarSummary(ctx context.Context, storyID int32) ([]GetAllUsersStoryGrammarSummaryRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersStoryGrammarSummary, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersStoryGrammarSummaryRow{}
	for rows.Next() {
		var i GetAllUsersStoryGrammarSummaryRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.Email,
			&i.TotalAttempts,
			&i.CorrectAnswers,
			&i.IncorrectAnswers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersStoryVocabSummary = `-- name: GetAllUsersStoryVocabSummary :many
SELECT
    vs.user_id,
    u.name as user_name,
    u.email,
    COUNT(*) as total_attempts,
    COUNT(CASE WHEN vs.correct = true THEN 1 END) as correct_answers,
    COUNT(CASE WHEN vs.correct = false THEN 1 END) as incorrect_answers
FROM vocab_scores vs
JOIN users u ON vs.user_id = u.user_id
WHERE vs.story_id = $1
GROUP BY vs.user_id, u.name, u.email
ORDER BY u.name
`

type GetAllUsersStoryVocabSummaryRow struct {
	UserID           string `json:"user_id"`
	UserName         string `json:"user_name"`
	Email            string `json:"email"`
	TotalAttempts    int64  `json:"total_attempts"`
	CorrectAnswers   int64  `json:"correct_answers"`
	IncorrectAnswers int64  `json:"incorrect_answers"`
}

func (q *Queries) GetAllUsersStoryVocabSummary(ctx context.Context, storyID int32) ([]GetAllUsersStoryVocabSummaryRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersStoryVocabSummary, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersStoryVocabSummaryRow{}
	for rows.Next() {
		var i GetAllUsersStoryVocabSummaryRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.Email,
			&i.TotalAttempts,
			&i.CorrectAnswers,
			&i.IncorrectAnswers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryGrammarScores = `-- name: GetStoryGrammarScores :many
SELECT gs.user_id, gs.line_number, gs.grammar_point_id, gs.correct, gs.attempted_at,
       gi.text, gp.name as grammar_point_name, u.name as user_name, u.email
FROM grammar_scores gs
JOIN grammar_points gp ON gs.grammar_point_id = gp.grammar_point_id
LEFT JOIN grammar_items gi ON gs.grammar_point_id = gi.grammar_point_id AND gs.story_id = gi.story_id AND gs.line_number = gi.line_number
JOIN users u ON gs.user_id = u.user_id
WHERE gs.story_id = $1
ORDER BY gs.line_number, gs.attempted_at DESC
`

type GetStoryGrammarScoresRow struct {
	UserID           string           `json:"user_id"`
	LineNumber       int32            `json:"line_number"`
	GrammarPointID   int32            `json:"grammar_point_id"`
	Correct          bool             `json:"correct"`
	AttemptedAt      pgtype.Timestamp `json:"attempted_at"`
	Text             pgtype.Text      `json:"text"`
	GrammarPointName string           `json:"grammar_point_name"`
	UserName         string           `json:"user_name"`
	Email            string           `json:"email"`
}

func (q *Queries) GetStoryGrammarScores(ctx context.Context, storyID int32) ([]GetStoryGrammarScoresRow, error) {
	rows, err := q.db.Query(ctx, getStoryGrammarScores, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoryGrammarScoresRow{}
	for rows.Next() {
		var i GetStoryGrammarScoresRow
		if err := rows.Scan(
			&i.UserID,
			&i.LineNumber,
			&i.GrammarPointID,
			&i.Correct,
			&i.AttemptedAt,
			&i.Text,
			&i.GrammarPointName,
			&i.UserName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryVocabScores = `-- name: GetStoryVocabScores :many
SELECT vs.user_id, vs.line_number, vs.vocab_item_id, vs.correct, vs.attempted_at,
       vi.word, vi.lexical_form, u.name as user_name, u.email
FROM vocab_scores vs
JOIN vocabulary_items vi ON vs.vocab_item_id = vi.id
JOIN users u ON vs.user_id = u.user_id
WHERE vs.story_id = $1
ORDER BY vs.line_number, vs.attempted_at DESC
`

type GetStoryVocabScoresRow struct {
	UserID      string           `json:"user_id"`
	LineNumber  int32            `json:"line_number"`
	VocabItemID int32            `json:"vocab_item_id"`
	Correct     bool             `json:"correct"`
	AttemptedAt pgtype.Timestamp `json:"attempted_at"`
	Word        string           `json:"word"`
	LexicalForm string           `json:"lexical_form"`
	UserName    string           `json:"user_name"`
	Email       string           `json:"email"`
}

func (q *Queries) GetStoryVocabScores(ctx context.Context, storyID int32) ([]GetStoryVocabScoresRow, error) {
	rows, err := q.db.Query(ctx, getStoryVocabScores, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoryVocabScoresRow{}
	for rows.Next() {
		var i GetStoryVocabScoresRow
		if err := rows.Scan(
			&i.UserID,
			&i.LineNumber,
			&i.VocabItemID,
			&i.Correct,
			&i.AttemptedAt,
			&i.Word,
			&i.LexicalForm,
			&i.UserName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGrammarScores = `-- name: GetUserGrammarScores :many
SELECT gs.line_number, gs.grammar_point_id, gs.correct, gs.attempted_at, gi.text, gp.name as grammar_point_name
FROM grammar_scores gs
JOIN grammar_points gp ON gs.grammar_point_id = gp.grammar_point_id
LEFT JOIN grammar_items gi ON gs.grammar_point_id = gi.grammar_point_id AND gs.story_id = gi.story_id AND gs.line_number = gi.line_number
WHERE gs.user_id = $1 AND gs.story_id = $2
ORDER BY gs.line_number, gs.attempted_at DESC
`

type GetUserGrammarScoresParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserGrammarScoresRow struct {
	LineNumber       int32            `json:"line_number"`
	GrammarPointID   int32            `json:"grammar_point_id"`
	Correct          bool             `json:"correct"`
	AttemptedAt      pgtype.Timestamp `json:"attempted_at"`
	Text             pgtype.Text      `json:"text"`
	GrammarPointName string           `json:"grammar_point_name"`
}

func (q *Queries) GetUserGrammarScores(ctx context.Context, arg GetUserGrammarScoresParams) ([]GetUserGrammarScoresRow, error) {
	rows, err := q.db.Query(ctx, getUserGrammarScores, arg.UserID, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserGrammarScoresRow{}
	for rows.Next() {
		var i GetUserGrammarScoresRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.GrammarPointID,
			&i.Correct,
			&i.AttemptedAt,
			&i.Text,
			&i.GrammarPointName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLatestGrammarScoresByLine = `-- name: GetUserLatestGrammarScoresByLine :many
SELECT DISTINCT ON (gs.line_number, gs.grammar_point_id)
    gs.line_number,
    gs.grammar_point_id,
    gs.correct,
    gs.attempted_at,
    gi.text,
    gp.name as grammar_point_name
FROM grammar_scores gs
JOIN grammar_points gp ON gs.grammar_point_id = gp.grammar_point_id
LEFT JOIN grammar_items gi ON gs.grammar_point_id = gi.grammar_point_id AND gs.story_id = gi.story_id AND gs.line_number = gi.line_number
WHERE gs.user_id = $1 AND gs.story_id = $2
ORDER BY gs.line_number, gs.grammar_point_id, gs.attempted_at DESC
`

type GetUserLatestGrammarScoresByLineParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserLatestGrammarScoresByLineRow struct {
	LineNumber       int32            `json:"line_number"`
	GrammarPointID   int32            `json:"grammar_point_id"`
	Correct          bool             `json:"correct"`
	AttemptedAt      pgtype.Timestamp `json:"attempted_at"`
	Text             pgtype.Text      `json:"text"`
	GrammarPointName string           `json:"grammar_point_name"`
}

func (q *Queries) GetUserLatestGrammarScoresByLine(ctx context.Context, arg GetUserLatestGrammarScoresByLineParams) ([]GetUserLatestGrammarScoresByLineRow, error) {
	rows, err := q.db.Query(ctx, getUserLatestGrammarScoresByLine, arg.UserID, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserLatestGrammarScoresByLineRow{}
	for rows.Next() {
		var i GetUserLatestGrammarScoresByLineRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.GrammarPointID,
			&i.Correct,
			&i.AttemptedAt,
			&i.Text,
			&i.GrammarPointName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLatestVocabScoresByLine = `-- name: GetUserLatestVocabScoresByLine :many
SELECT DISTINCT ON (vs.line_number, vs.vocab_item_id)
    vs.line_number,
    vs.vocab_item_id,
    vs.correct,
    vs.attempted_at,
    vi.word,
    vi.lexical_form
FROM vocab_scores vs
JOIN vocabulary_items vi ON vs.vocab_item_id = vi.id
WHERE vs.user_id = $1 AND vs.story_id = $2
ORDER BY vs.line_number, vs.vocab_item_id, vs.attempted_at DESC
`

type GetUserLatestVocabScoresByLineParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserLatestVocabScoresByLineRow struct {
	LineNumber  int32            `json:"line_number"`
	VocabItemID int32            `json:"vocab_item_id"`
	Correct     bool             `json:"correct"`
	AttemptedAt pgtype.Timestamp `json:"attempted_at"`
	Word        string           `json:"word"`
	LexicalForm string           `json:"lexical_form"`
}

func (q *Queries) GetUserLatestVocabScoresByLine(ctx context.Context, arg GetUserLatestVocabScoresByLineParams) ([]GetUserLatestVocabScoresByLineRow, error) {
	rows, err := q.db.Query(ctx, getUserLatestVocabScoresByLine, arg.UserID, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserLatestVocabScoresByLineRow{}
	for rows.Next() {
		var i GetUserLatestVocabScoresByLineRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.VocabItemID,
			&i.Correct,
			&i.AttemptedAt,
			&i.Word,
			&i.LexicalForm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoryGrammarSummary = `-- name: GetUserStoryGrammarSummary :one
SELECT
    COUNT(*) as total_attempts,
    COUNT(CASE WHEN gs.correct = true THEN 1 END) as correct_answers,
    COUNT(CASE WHEN gs.correct = false THEN 1 END) as incorrect_answers
FROM grammar_scores gs
WHERE gs.user_id = $1 AND gs.story_id = $2
`

type GetUserStoryGrammarSummaryParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserStoryGrammarSummaryRow struct {
	TotalAttempts    int64 `json:"total_attempts"`
	CorrectAnswers   int64 `json:"correct_answers"`
	IncorrectAnswers int64 `json:"incorrect_answers"`
}

func (q *Queries) GetUserStoryGrammarSummary(ctx context.Context, arg GetUserStoryGrammarSummaryParams) (GetUserStoryGrammarSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserStoryGrammarSummary, arg.UserID, arg.StoryID)
	var i GetUserStoryGrammarSummaryRow
	err := row.Scan(&i.TotalAttempts, &i.CorrectAnswers, &i.IncorrectAnswers)
	return i, err
}

const getUserStoryVocabSummary = `-- name: GetUserStoryVocabSummary :one
SELECT
    COUNT(*) as total_attempts,
    COUNT(CASE WHEN vs.correct = true THEN 1 END) as correct_answers,
    COUNT(CASE WHEN vs.correct = false THEN 1 END) as incorrect_answers
FROM vocab_scores vs
WHERE vs.user_id = $1 AND vs.story_id = $2
`

type GetUserStoryVocabSummaryParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserStoryVocabSummaryRow struct {
	TotalAttempts    int64 `json:"total_attempts"`
	CorrectAnswers   int64 `json:"correct_answers"`
	IncorrectAnswers int64 `json:"incorrect_answers"`
}

func (q *Queries) GetUserStoryVocabSummary(ctx context.Context, arg GetUserStoryVocabSummaryParams) (GetUserStoryVocabSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserStoryVocabSummary, arg.UserID, arg.StoryID)
	var i GetUserStoryVocabSummaryRow
	err := row.Scan(&i.TotalAttempts, &i.CorrectAnswers, &i.IncorrectAnswers)
	return i, err
}

const getUserVocabScores = `-- name: GetUserVocabScores :many
SELECT vs.line_number, vs.vocab_item_id, vs.correct, vs.attempted_at, vi.word, vi.lexical_form
FROM vocab_scores vs
JOIN vocabulary_items vi ON vs.vocab_item_id = vi.id
WHERE vs.user_id = $1 AND vs.story_id = $2
ORDER BY vs.line_number, vs.attempted_at DESC
`

type GetUserVocabScoresParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserVocabScoresRow struct {
	LineNumber  int32            `json:"line_number"`
	VocabItemID int32            `json:"vocab_item_id"`
	Correct     bool             `json:"correct"`
	AttemptedAt pgtype.Timestamp `json:"attempted_at"`
	Word        string           `json:"word"`
	LexicalForm string           `json:"lexical_form"`
}

func (q *Queries) GetUserVocabScores(ctx context.Context, arg GetUserVocabScoresParams) ([]GetUserVocabScoresRow, error) {
	rows, err := q.db.Query(ctx, getUserVocabScores, arg.UserID, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserVocabScoresRow{}
	for rows.Next() {
		var i GetUserVocabScoresRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.VocabItemID,
			&i.Correct,
			&i.AttemptedAt,
			&i.Word,
			&i.LexicalForm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveGrammarIncorrectAnswer = `-- name: SaveGrammarIncorrectAnswer :exec
INSERT INTO grammar_incorrect_answers (user_id, story_id, line_number, grammar_point_id, selected_line, selected_positions)
VALUES ($1, $2, $3, $4, $5, $6)
`

type SaveGrammarIncorrectAnswerParams struct {
	UserID            string  `json:"user_id"`
	StoryID           int32   `json:"story_id"`
	LineNumber        int32   `json:"line_number"`
	GrammarPointID    int32   `json:"grammar_point_id"`
	SelectedLine      int32   `json:"selected_line"`
	SelectedPositions []int32 `json:"selected_positions"`
}

func (q *Queries) SaveGrammarIncorrectAnswer(ctx context.Context, arg SaveGrammarIncorrectAnswerParams) error {
	_, err := q.db.Exec(ctx, saveGrammarIncorrectAnswer,
		arg.UserID,
		arg.StoryID,
		arg.LineNumber,
		arg.GrammarPointID,
		arg.SelectedLine,
		arg.SelectedPositions,
	)
	return err
}

const saveGrammarScore = `-- name: SaveGrammarScore :exec
INSERT INTO grammar_scores (user_id, story_id, line_number, grammar_point_id, correct)
VALUES ($1, $2, $3, $4, $5)
`

type SaveGrammarScoreParams struct {
	UserID         string `json:"user_id"`
	StoryID        int32  `json:"story_id"`
	LineNumber     int32  `json:"line_number"`
	GrammarPointID int32  `json:"grammar_point_id"`
	Correct        bool   `json:"correct"`
}

func (q *Queries) SaveGrammarScore(ctx context.Context, arg SaveGrammarScoreParams) error {
	_, err := q.db.Exec(ctx, saveGrammarScore,
		arg.UserID,
		arg.StoryID,
		arg.LineNumber,
		arg.GrammarPointID,
		arg.Correct,
	)
	return err
}

const saveVocabIncorrectAnswer = `-- name: SaveVocabIncorrectAnswer :exec
INSERT INTO vocab_incorrect_answers (user_id, story_id, line_number, vocab_item_id, incorrect_answer)
VALUES ($1, $2, $3, $4, $5)
`

type SaveVocabIncorrectAnswerParams struct {
	UserID          string `json:"user_id"`
	StoryID         int32  `json:"story_id"`
	LineNumber      int32  `json:"line_number"`
	VocabItemID     int32  `json:"vocab_item_id"`
	IncorrectAnswer string `json:"incorrect_answer"`
}

func (q *Queries) SaveVocabIncorrectAnswer(ctx context.Context, arg SaveVocabIncorrectAnswerParams) error {
	_, err := q.db.Exec(ctx, saveVocabIncorrectAnswer,
		arg.UserID,
		arg.StoryID,
		arg.LineNumber,
		arg.VocabItemID,
		arg.IncorrectAnswer,
	)
	return err
}

const saveVocabScore = `-- name: SaveVocabScore :exec

INSERT INTO vocab_scores (user_id, story_id, line_number, vocab_item_id, correct)
VALUES ($1, $2, $3, $4, $5)
`

type SaveVocabScoreParams struct {
	UserID      string `json:"user_id"`
	StoryID     int32  `json:"story_id"`
	LineNumber  int32  `json:"line_number"`
	VocabItemID int32  `json:"vocab_item_id"`
	Correct     bool   `json:"correct"`
}

// Score management queries
func (q *Queries) SaveVocabScore(ctx context.Context, arg SaveVocabScoreParams) error {
	_, err := q.db.Exec(ctx, saveVocabScore,
		arg.UserID,
		arg.StoryID,
		arg.LineNumber,
		arg.VocabItemID,
		arg.Correct,
	)
	return err
}
