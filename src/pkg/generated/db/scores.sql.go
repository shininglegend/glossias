// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: scores.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countStoryGrammarItems = `-- name: CountStoryGrammarItems :one
SELECT COUNT(*) as total_grammar_items
FROM grammar_items
WHERE story_id = $1
`

func (q *Queries) CountStoryGrammarItems(ctx context.Context, storyID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countStoryGrammarItems, storyID)
	var total_grammar_items int64
	err := row.Scan(&total_grammar_items)
	return total_grammar_items, err
}

const countStoryVocabItems = `-- name: CountStoryVocabItems :one
SELECT COUNT(*) as total_vocab_items
FROM vocabulary_items
WHERE story_id = $1
`

func (q *Queries) CountStoryVocabItems(ctx context.Context, storyID pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countStoryVocabItems, storyID)
	var total_vocab_items int64
	err := row.Scan(&total_vocab_items)
	return total_vocab_items, err
}

const getAllUsersStoryGrammarSummary = `-- name: GetAllUsersStoryGrammarSummary :many
SELECT
    COALESCE(gca.user_id, gia.user_id) as user_id,
    u.name as user_name,
    u.email,
    COUNT(gca.grammar_point_id) as correct_answers,
    COUNT(gia.grammar_point_id) as incorrect_answers
FROM grammar_correct_answers gca
FULL OUTER JOIN grammar_incorrect_answers gia ON gca.user_id = gia.user_id AND gca.story_id = gia.story_id
JOIN users u ON COALESCE(gca.user_id, gia.user_id) = u.user_id
WHERE COALESCE(gca.story_id, gia.story_id) = $1
GROUP BY COALESCE(gca.user_id, gia.user_id), u.name, u.email
ORDER BY u.name
`

type GetAllUsersStoryGrammarSummaryRow struct {
	UserID           string `json:"user_id"`
	UserName         string `json:"user_name"`
	Email            string `json:"email"`
	CorrectAnswers   int64  `json:"correct_answers"`
	IncorrectAnswers int64  `json:"incorrect_answers"`
}

func (q *Queries) GetAllUsersStoryGrammarSummary(ctx context.Context, storyID int32) ([]GetAllUsersStoryGrammarSummaryRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersStoryGrammarSummary, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersStoryGrammarSummaryRow{}
	for rows.Next() {
		var i GetAllUsersStoryGrammarSummaryRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.Email,
			&i.CorrectAnswers,
			&i.IncorrectAnswers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsersStoryVocabSummary = `-- name: GetAllUsersStoryVocabSummary :many
SELECT
    COALESCE(vca.user_id, via.user_id) as user_id,
    u.name as user_name,
    u.email,
    COUNT(vca.vocab_item_id) as correct_answers,
    COUNT(via.vocab_item_id) as incorrect_answers
FROM vocab_correct_answers vca
FULL OUTER JOIN vocab_incorrect_answers via ON vca.user_id = via.user_id AND vca.story_id = via.story_id
JOIN users u ON COALESCE(vca.user_id, via.user_id) = u.user_id
WHERE COALESCE(vca.story_id, via.story_id) = $1
GROUP BY COALESCE(vca.user_id, via.user_id), u.name, u.email
ORDER BY u.name
`

type GetAllUsersStoryVocabSummaryRow struct {
	UserID           string `json:"user_id"`
	UserName         string `json:"user_name"`
	Email            string `json:"email"`
	CorrectAnswers   int64  `json:"correct_answers"`
	IncorrectAnswers int64  `json:"incorrect_answers"`
}

func (q *Queries) GetAllUsersStoryVocabSummary(ctx context.Context, storyID int32) ([]GetAllUsersStoryVocabSummaryRow, error) {
	rows, err := q.db.Query(ctx, getAllUsersStoryVocabSummary, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllUsersStoryVocabSummaryRow{}
	for rows.Next() {
		var i GetAllUsersStoryVocabSummaryRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.Email,
			&i.CorrectAnswers,
			&i.IncorrectAnswers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryGrammarScores = `-- name: GetStoryGrammarScores :many
SELECT gs.user_id, gs.line_number, gs.grammar_point_id, gs.attempted_at,
       gi.text, gp.name as grammar_point_name, u.name as user_name, u.email
FROM grammar_correct_answers gs
JOIN grammar_points gp ON gs.grammar_point_id = gp.grammar_point_id
LEFT JOIN grammar_items gi ON gs.grammar_point_id = gi.grammar_point_id AND gs.story_id = gi.story_id AND gs.line_number = gi.line_number
JOIN users u ON gs.user_id = u.user_id
WHERE gs.story_id = $1
ORDER BY gs.line_number, gs.attempted_at DESC
`

type GetStoryGrammarScoresRow struct {
	UserID           string           `json:"user_id"`
	LineNumber       int32            `json:"line_number"`
	GrammarPointID   int32            `json:"grammar_point_id"`
	AttemptedAt      pgtype.Timestamp `json:"attempted_at"`
	Text             pgtype.Text      `json:"text"`
	GrammarPointName string           `json:"grammar_point_name"`
	UserName         string           `json:"user_name"`
	Email            string           `json:"email"`
}

func (q *Queries) GetStoryGrammarScores(ctx context.Context, storyID int32) ([]GetStoryGrammarScoresRow, error) {
	rows, err := q.db.Query(ctx, getStoryGrammarScores, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoryGrammarScoresRow{}
	for rows.Next() {
		var i GetStoryGrammarScoresRow
		if err := rows.Scan(
			&i.UserID,
			&i.LineNumber,
			&i.GrammarPointID,
			&i.AttemptedAt,
			&i.Text,
			&i.GrammarPointName,
			&i.UserName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryStudentPerformance = `-- name: GetStoryStudentPerformance :many
SELECT
    u.user_id,
    u.name as user_name,
    u.email,
    st.title as story_title,
    COALESCE(vocab_stats.correct_count, 0) as vocab_correct,
    COALESCE(vocab_stats.incorrect_count, 0) as vocab_incorrect,
    COALESCE(grammar_stats.correct_count, 0) as grammar_correct,
    COALESCE(grammar_stats.incorrect_count, 0) as grammar_incorrect,
    COALESCE(tr.completed, false) as translation_completed,
    COALESCE(tr.requested_lines, ARRAY[]::INTEGER[]) as requested_lines,
    COALESCE(time_stats.vocab_time_seconds, 0) as vocab_time_seconds,
    COALESCE(time_stats.grammar_time_seconds, 0) as grammar_time_seconds,
    COALESCE(time_stats.translation_time_seconds, 0) as translation_time_seconds,
    COALESCE(time_stats.video_time_seconds, 0) as video_time_seconds,
    COALESCE(time_stats.vocab_time_seconds, 0) +
    COALESCE(time_stats.grammar_time_seconds, 0) +
    COALESCE(time_stats.translation_time_seconds, 0) +
    COALESCE(time_stats.video_time_seconds, 0) as total_time_seconds
FROM users u
JOIN course_users cu ON u.user_id = cu.user_id
JOIN stories s ON cu.course_id = s.course_id
LEFT JOIN story_titles st ON s.story_id = st.story_id AND st.language_code = 'en'
LEFT JOIN LATERAL (
    SELECT
        (SELECT COUNT(*) FROM vocab_correct_answers vca WHERE vca.user_id = u.user_id AND vca.story_id = s.story_id) as correct_count,
        (SELECT COUNT(*) FROM vocab_incorrect_answers via WHERE via.user_id = u.user_id AND via.story_id = s.story_id) as incorrect_count
) vocab_stats ON true
LEFT JOIN LATERAL (
    SELECT
        (SELECT COUNT(*) FROM grammar_correct_answers gca WHERE gca.user_id = u.user_id AND gca.story_id = s.story_id) as correct_count,
        (SELECT COUNT(*) FROM grammar_incorrect_answers gia WHERE gia.user_id = u.user_id AND gia.story_id = s.story_id) as incorrect_count
) grammar_stats ON true
LEFT JOIN LATERAL (
    SELECT
        EXISTS(SELECT 1 FROM translation_requests WHERE user_id = u.user_id AND story_id = s.story_id) as completed,
        COALESCE((SELECT requested_lines FROM translation_requests WHERE user_id = u.user_id AND story_id = s.story_id LIMIT 1), ARRAY[]::INTEGER[]) as requested_lines
) tr ON true
LEFT JOIN LATERAL (
    SELECT
        COALESCE(SUM(CASE WHEN route LIKE '%vocab%' THEN total_time_seconds END), 0) as vocab_time_seconds,
        COALESCE(SUM(CASE WHEN route LIKE '%grammar%' THEN total_time_seconds END), 0) as grammar_time_seconds,
        COALESCE(SUM(CASE WHEN route LIKE '%translate%' THEN total_time_seconds END), 0) as translation_time_seconds,
        COALESCE(SUM(CASE WHEN route LIKE '%audio%' OR route LIKE '%video%' THEN total_time_seconds END), 0) as video_time_seconds
    FROM user_time_tracking
    WHERE user_id = u.user_id AND story_id = s.story_id AND ended_at IS NOT NULL
) time_stats ON true
WHERE s.story_id = $1
ORDER BY u.name
`

type GetStoryStudentPerformanceRow struct {
	UserID                 string      `json:"user_id"`
	UserName               string      `json:"user_name"`
	Email                  string      `json:"email"`
	StoryTitle             pgtype.Text `json:"story_title"`
	VocabCorrect           int64       `json:"vocab_correct"`
	VocabIncorrect         int64       `json:"vocab_incorrect"`
	GrammarCorrect         int64       `json:"grammar_correct"`
	GrammarIncorrect       int64       `json:"grammar_incorrect"`
	TranslationCompleted   bool        `json:"translation_completed"`
	RequestedLines         interface{} `json:"requested_lines"`
	VocabTimeSeconds       interface{} `json:"vocab_time_seconds"`
	GrammarTimeSeconds     interface{} `json:"grammar_time_seconds"`
	TranslationTimeSeconds interface{} `json:"translation_time_seconds"`
	VideoTimeSeconds       interface{} `json:"video_time_seconds"`
	TotalTimeSeconds       int32       `json:"total_time_seconds"`
}

func (q *Queries) GetStoryStudentPerformance(ctx context.Context, storyID int32) ([]GetStoryStudentPerformanceRow, error) {
	rows, err := q.db.Query(ctx, getStoryStudentPerformance, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoryStudentPerformanceRow{}
	for rows.Next() {
		var i GetStoryStudentPerformanceRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.Email,
			&i.StoryTitle,
			&i.VocabCorrect,
			&i.VocabIncorrect,
			&i.GrammarCorrect,
			&i.GrammarIncorrect,
			&i.TranslationCompleted,
			&i.RequestedLines,
			&i.VocabTimeSeconds,
			&i.GrammarTimeSeconds,
			&i.TranslationTimeSeconds,
			&i.VideoTimeSeconds,
			&i.TotalTimeSeconds,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryVocabScores = `-- name: GetStoryVocabScores :many
SELECT vs.user_id, vs.line_number, vs.vocab_item_id, vs.attempted_at,
       vi.word, vi.lexical_form, u.name as user_name, u.email
FROM vocab_correct_answers vs
JOIN vocabulary_items vi ON vs.vocab_item_id = vi.id
JOIN users u ON vs.user_id = u.user_id
WHERE vs.story_id = $1
ORDER BY vs.line_number, vs.attempted_at DESC
`

type GetStoryVocabScoresRow struct {
	UserID      string           `json:"user_id"`
	LineNumber  int32            `json:"line_number"`
	VocabItemID int32            `json:"vocab_item_id"`
	AttemptedAt pgtype.Timestamp `json:"attempted_at"`
	Word        string           `json:"word"`
	LexicalForm string           `json:"lexical_form"`
	UserName    string           `json:"user_name"`
	Email       string           `json:"email"`
}

func (q *Queries) GetStoryVocabScores(ctx context.Context, storyID int32) ([]GetStoryVocabScoresRow, error) {
	rows, err := q.db.Query(ctx, getStoryVocabScores, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStoryVocabScoresRow{}
	for rows.Next() {
		var i GetStoryVocabScoresRow
		if err := rows.Scan(
			&i.UserID,
			&i.LineNumber,
			&i.VocabItemID,
			&i.AttemptedAt,
			&i.Word,
			&i.LexicalForm,
			&i.UserName,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGrammarIncorrectAnswers = `-- name: GetUserGrammarIncorrectAnswers :many
SELECT gia.line_number, gia.grammar_point_id, gia.selected_line, gia.selected_positions, gia.attempted_at
FROM grammar_incorrect_answers gia
WHERE gia.user_id = $1 AND gia.story_id = $2 AND gia.grammar_point_id = $3
ORDER BY gia.line_number, gia.attempted_at DESC
`

type GetUserGrammarIncorrectAnswersParams struct {
	UserID         string `json:"user_id"`
	StoryID        int32  `json:"story_id"`
	GrammarPointID int32  `json:"grammar_point_id"`
}

type GetUserGrammarIncorrectAnswersRow struct {
	LineNumber        int32            `json:"line_number"`
	GrammarPointID    int32            `json:"grammar_point_id"`
	SelectedLine      int32            `json:"selected_line"`
	SelectedPositions []int32          `json:"selected_positions"`
	AttemptedAt       pgtype.Timestamp `json:"attempted_at"`
}

func (q *Queries) GetUserGrammarIncorrectAnswers(ctx context.Context, arg GetUserGrammarIncorrectAnswersParams) ([]GetUserGrammarIncorrectAnswersRow, error) {
	rows, err := q.db.Query(ctx, getUserGrammarIncorrectAnswers, arg.UserID, arg.StoryID, arg.GrammarPointID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserGrammarIncorrectAnswersRow{}
	for rows.Next() {
		var i GetUserGrammarIncorrectAnswersRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.GrammarPointID,
			&i.SelectedLine,
			&i.SelectedPositions,
			&i.AttemptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGrammarScores = `-- name: GetUserGrammarScores :many
SELECT gs.line_number, gs.grammar_point_id, gs.attempted_at, gi.text, gp.name as grammar_point_name
FROM grammar_correct_answers gs
JOIN grammar_points gp ON gs.grammar_point_id = gp.grammar_point_id
LEFT JOIN grammar_items gi ON gs.grammar_point_id = gi.grammar_point_id AND gs.story_id = gi.story_id AND gs.line_number = gi.line_number
WHERE gs.user_id = $1 AND gs.story_id = $2
ORDER BY gs.line_number, gs.attempted_at DESC
`

type GetUserGrammarScoresParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserGrammarScoresRow struct {
	LineNumber       int32            `json:"line_number"`
	GrammarPointID   int32            `json:"grammar_point_id"`
	AttemptedAt      pgtype.Timestamp `json:"attempted_at"`
	Text             pgtype.Text      `json:"text"`
	GrammarPointName string           `json:"grammar_point_name"`
}

func (q *Queries) GetUserGrammarScores(ctx context.Context, arg GetUserGrammarScoresParams) ([]GetUserGrammarScoresRow, error) {
	rows, err := q.db.Query(ctx, getUserGrammarScores, arg.UserID, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserGrammarScoresRow{}
	for rows.Next() {
		var i GetUserGrammarScoresRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.GrammarPointID,
			&i.AttemptedAt,
			&i.Text,
			&i.GrammarPointName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGrammarScoresByGrammarPoint = `-- name: GetUserGrammarScoresByGrammarPoint :many
SELECT gs.line_number, gs.grammar_point_id, gs.attempted_at
FROM grammar_correct_answers gs
WHERE gs.user_id = $1 AND gs.story_id = $2 AND gs.grammar_point_id = $3
ORDER BY gs.line_number, gs.attempted_at DESC
`

type GetUserGrammarScoresByGrammarPointParams struct {
	UserID         string `json:"user_id"`
	StoryID        int32  `json:"story_id"`
	GrammarPointID int32  `json:"grammar_point_id"`
}

type GetUserGrammarScoresByGrammarPointRow struct {
	LineNumber     int32            `json:"line_number"`
	GrammarPointID int32            `json:"grammar_point_id"`
	AttemptedAt    pgtype.Timestamp `json:"attempted_at"`
}

func (q *Queries) GetUserGrammarScoresByGrammarPoint(ctx context.Context, arg GetUserGrammarScoresByGrammarPointParams) ([]GetUserGrammarScoresByGrammarPointRow, error) {
	rows, err := q.db.Query(ctx, getUserGrammarScoresByGrammarPoint, arg.UserID, arg.StoryID, arg.GrammarPointID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserGrammarScoresByGrammarPointRow{}
	for rows.Next() {
		var i GetUserGrammarScoresByGrammarPointRow
		if err := rows.Scan(&i.LineNumber, &i.GrammarPointID, &i.AttemptedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLatestGrammarScoresByLine = `-- name: GetUserLatestGrammarScoresByLine :many
SELECT DISTINCT ON (gs.line_number, gs.grammar_point_id)
    gs.line_number,
    gs.grammar_point_id,
    gs.attempted_at,
    gi.text,
    gp.name as grammar_point_name
FROM grammar_correct_answers gs
JOIN grammar_points gp ON gs.grammar_point_id = gp.grammar_point_id
LEFT JOIN grammar_items gi ON gs.grammar_point_id = gi.grammar_point_id AND gs.story_id = gi.story_id AND gs.line_number = gi.line_number
WHERE gs.user_id = $1 AND gs.story_id = $2
ORDER BY gs.line_number, gs.grammar_point_id, gs.attempted_at DESC
`

type GetUserLatestGrammarScoresByLineParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserLatestGrammarScoresByLineRow struct {
	LineNumber       int32            `json:"line_number"`
	GrammarPointID   int32            `json:"grammar_point_id"`
	AttemptedAt      pgtype.Timestamp `json:"attempted_at"`
	Text             pgtype.Text      `json:"text"`
	GrammarPointName string           `json:"grammar_point_name"`
}

func (q *Queries) GetUserLatestGrammarScoresByLine(ctx context.Context, arg GetUserLatestGrammarScoresByLineParams) ([]GetUserLatestGrammarScoresByLineRow, error) {
	rows, err := q.db.Query(ctx, getUserLatestGrammarScoresByLine, arg.UserID, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserLatestGrammarScoresByLineRow{}
	for rows.Next() {
		var i GetUserLatestGrammarScoresByLineRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.GrammarPointID,
			&i.AttemptedAt,
			&i.Text,
			&i.GrammarPointName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserLatestVocabScoresByLine = `-- name: GetUserLatestVocabScoresByLine :many
SELECT DISTINCT ON (vs.line_number, vs.vocab_item_id)
    vs.line_number,
    vs.vocab_item_id,
    vs.attempted_at,
    vi.word,
    vi.lexical_form
FROM vocab_correct_answers vs
JOIN vocabulary_items vi ON vs.vocab_item_id = vi.id
WHERE vs.user_id = $1 AND vs.story_id = $2
ORDER BY vs.line_number, vs.vocab_item_id, vs.attempted_at DESC
`

type GetUserLatestVocabScoresByLineParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserLatestVocabScoresByLineRow struct {
	LineNumber  int32            `json:"line_number"`
	VocabItemID int32            `json:"vocab_item_id"`
	AttemptedAt pgtype.Timestamp `json:"attempted_at"`
	Word        string           `json:"word"`
	LexicalForm string           `json:"lexical_form"`
}

func (q *Queries) GetUserLatestVocabScoresByLine(ctx context.Context, arg GetUserLatestVocabScoresByLineParams) ([]GetUserLatestVocabScoresByLineRow, error) {
	rows, err := q.db.Query(ctx, getUserLatestVocabScoresByLine, arg.UserID, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserLatestVocabScoresByLineRow{}
	for rows.Next() {
		var i GetUserLatestVocabScoresByLineRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.VocabItemID,
			&i.AttemptedAt,
			&i.Word,
			&i.LexicalForm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStoryGrammarSummary = `-- name: GetUserStoryGrammarSummary :one
SELECT
    (SELECT COUNT(*) FROM grammar_correct_answers gca WHERE gca.user_id = $1 AND gca.story_id = $2) as correct_count,
    (SELECT COUNT(*) FROM grammar_incorrect_answers gia WHERE gia.user_id = $1 AND gia.story_id = $2) as incorrect_count
`

type GetUserStoryGrammarSummaryParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserStoryGrammarSummaryRow struct {
	CorrectCount   int64 `json:"correct_count"`
	IncorrectCount int64 `json:"incorrect_count"`
}

func (q *Queries) GetUserStoryGrammarSummary(ctx context.Context, arg GetUserStoryGrammarSummaryParams) (GetUserStoryGrammarSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserStoryGrammarSummary, arg.UserID, arg.StoryID)
	var i GetUserStoryGrammarSummaryRow
	err := row.Scan(&i.CorrectCount, &i.IncorrectCount)
	return i, err
}

const getUserStoryVocabSummary = `-- name: GetUserStoryVocabSummary :one
SELECT
    (SELECT COUNT(*) FROM vocab_correct_answers vca WHERE vca.user_id = $1 AND vca.story_id = $2) as correct_count,
    (SELECT COUNT(*) FROM vocab_incorrect_answers via WHERE via.user_id = $1 AND via.story_id = $2) as incorrect_count
`

type GetUserStoryVocabSummaryParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserStoryVocabSummaryRow struct {
	CorrectCount   int64 `json:"correct_count"`
	IncorrectCount int64 `json:"incorrect_count"`
}

func (q *Queries) GetUserStoryVocabSummary(ctx context.Context, arg GetUserStoryVocabSummaryParams) (GetUserStoryVocabSummaryRow, error) {
	row := q.db.QueryRow(ctx, getUserStoryVocabSummary, arg.UserID, arg.StoryID)
	var i GetUserStoryVocabSummaryRow
	err := row.Scan(&i.CorrectCount, &i.IncorrectCount)
	return i, err
}

const getUserVocabScores = `-- name: GetUserVocabScores :many
SELECT vs.line_number, vs.vocab_item_id, vs.attempted_at, vi.word, vi.lexical_form
FROM vocab_correct_answers vs
JOIN vocabulary_items vi ON vs.vocab_item_id = vi.id
WHERE vs.user_id = $1 AND vs.story_id = $2
ORDER BY vs.line_number, vs.attempted_at DESC
`

type GetUserVocabScoresParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserVocabScoresRow struct {
	LineNumber  int32            `json:"line_number"`
	VocabItemID int32            `json:"vocab_item_id"`
	AttemptedAt pgtype.Timestamp `json:"attempted_at"`
	Word        string           `json:"word"`
	LexicalForm string           `json:"lexical_form"`
}

func (q *Queries) GetUserVocabScores(ctx context.Context, arg GetUserVocabScoresParams) ([]GetUserVocabScoresRow, error) {
	rows, err := q.db.Query(ctx, getUserVocabScores, arg.UserID, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserVocabScoresRow{}
	for rows.Next() {
		var i GetUserVocabScoresRow
		if err := rows.Scan(
			&i.LineNumber,
			&i.VocabItemID,
			&i.AttemptedAt,
			&i.Word,
			&i.LexicalForm,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveGrammarIncorrectAnswer = `-- name: SaveGrammarIncorrectAnswer :exec
INSERT INTO grammar_incorrect_answers (user_id, story_id, line_number, grammar_point_id, selected_line, selected_positions)
VALUES ($1, $2, $3, $4, $5, $6)
`

type SaveGrammarIncorrectAnswerParams struct {
	UserID            string  `json:"user_id"`
	StoryID           int32   `json:"story_id"`
	LineNumber        int32   `json:"line_number"`
	GrammarPointID    int32   `json:"grammar_point_id"`
	SelectedLine      int32   `json:"selected_line"`
	SelectedPositions []int32 `json:"selected_positions"`
}

func (q *Queries) SaveGrammarIncorrectAnswer(ctx context.Context, arg SaveGrammarIncorrectAnswerParams) error {
	_, err := q.db.Exec(ctx, saveGrammarIncorrectAnswer,
		arg.UserID,
		arg.StoryID,
		arg.LineNumber,
		arg.GrammarPointID,
		arg.SelectedLine,
		arg.SelectedPositions,
	)
	return err
}

const saveGrammarScore = `-- name: SaveGrammarScore :exec

INSERT INTO grammar_correct_answers (user_id, story_id, line_number, grammar_point_id)
VALUES ($1, $2, $3, $4)
`

type SaveGrammarScoreParams struct {
	UserID         string `json:"user_id"`
	StoryID        int32  `json:"story_id"`
	LineNumber     int32  `json:"line_number"`
	GrammarPointID int32  `json:"grammar_point_id"`
}

// Score management queries
func (q *Queries) SaveGrammarScore(ctx context.Context, arg SaveGrammarScoreParams) error {
	_, err := q.db.Exec(ctx, saveGrammarScore,
		arg.UserID,
		arg.StoryID,
		arg.LineNumber,
		arg.GrammarPointID,
	)
	return err
}
