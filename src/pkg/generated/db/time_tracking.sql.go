// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: time_tracking.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const accumulateTimeEntry = `-- name: AccumulateTimeEntry :exec
UPDATE user_time_tracking
SET total_time_seconds = COALESCE(total_time_seconds, 0) + $2,
    ended_at = $3
WHERE tracking_id = $1
`

type AccumulateTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
}

func (q *Queries) AccumulateTimeEntry(ctx context.Context, arg AccumulateTimeEntryParams) error {
	_, err := q.db.Exec(ctx, accumulateTimeEntry, arg.TrackingID, arg.TotalTimeSeconds, arg.EndedAt)
	return err
}

const closeAnonymousTimeEntry = `-- name: CloseAnonymousTimeEntry :exec
UPDATE anonymous_time_tracking
SET ended_at = $2, total_time_seconds = $3
WHERE tracking_id = $1
`

type CloseAnonymousTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) CloseAnonymousTimeEntry(ctx context.Context, arg CloseAnonymousTimeEntryParams) error {
	_, err := q.db.Exec(ctx, closeAnonymousTimeEntry, arg.TrackingID, arg.EndedAt, arg.TotalTimeSeconds)
	return err
}

const closeTimeEntry = `-- name: CloseTimeEntry :exec
UPDATE user_time_tracking
SET ended_at = $2, total_time_seconds = $3
WHERE tracking_id = $1
`

type CloseTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) CloseTimeEntry(ctx context.Context, arg CloseTimeEntryParams) error {
	_, err := q.db.Exec(ctx, closeTimeEntry, arg.TrackingID, arg.EndedAt, arg.TotalTimeSeconds)
	return err
}

const createAnonymousTimeEntry = `-- name: CreateAnonymousTimeEntry :one

INSERT INTO anonymous_time_tracking (session_id, route, story_id, started_at)
VALUES ($1, $2, $3, $4)
RETURNING tracking_id, session_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type CreateAnonymousTimeEntryParams struct {
	SessionID string           `json:"session_id"`
	Route     string           `json:"route"`
	StoryID   pgtype.Int4      `json:"story_id"`
	StartedAt pgtype.Timestamp `json:"started_at"`
}

// Anonymous time tracking queries
func (q *Queries) CreateAnonymousTimeEntry(ctx context.Context, arg CreateAnonymousTimeEntryParams) (AnonymousTimeTracking, error) {
	row := q.db.QueryRow(ctx, createAnonymousTimeEntry,
		arg.SessionID,
		arg.Route,
		arg.StoryID,
		arg.StartedAt,
	)
	var i AnonymousTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.SessionID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const createCompleteTimeEntry = `-- name: CreateCompleteTimeEntry :one
INSERT INTO user_time_tracking (user_id, route, story_id, started_at, ended_at, total_time_seconds)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type CreateCompleteTimeEntryParams struct {
	UserID           string           `json:"user_id"`
	Route            string           `json:"route"`
	StoryID          pgtype.Int4      `json:"story_id"`
	StartedAt        pgtype.Timestamp `json:"started_at"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) CreateCompleteTimeEntry(ctx context.Context, arg CreateCompleteTimeEntryParams) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, createCompleteTimeEntry,
		arg.UserID,
		arg.Route,
		arg.StoryID,
		arg.StartedAt,
		arg.EndedAt,
		arg.TotalTimeSeconds,
	)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const createTimeEntry = `-- name: CreateTimeEntry :one

INSERT INTO user_time_tracking (user_id, route, story_id, started_at)
VALUES ($1, $2, $3, $4)
RETURNING tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type CreateTimeEntryParams struct {
	UserID    string           `json:"user_id"`
	Route     string           `json:"route"`
	StoryID   pgtype.Int4      `json:"story_id"`
	StartedAt pgtype.Timestamp `json:"started_at"`
}

// Time tracking queries
func (q *Queries) CreateTimeEntry(ctx context.Context, arg CreateTimeEntryParams) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, createTimeEntry,
		arg.UserID,
		arg.Route,
		arg.StoryID,
		arg.StartedAt,
	)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldAnonymousEntries = `-- name: DeleteOldAnonymousEntries :exec
DELETE FROM anonymous_time_tracking
WHERE created_at < $1
`

func (q *Queries) DeleteOldAnonymousEntries(ctx context.Context, createdAt pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, deleteOldAnonymousEntries, createdAt)
	return err
}

const findRecentSimilarTimeEntry = `-- name: FindRecentSimilarTimeEntry :one
SELECT tracking_id, total_time_seconds
FROM user_time_tracking
WHERE user_id = $1
  AND route = $2
  AND story_id IS NOT DISTINCT FROM $3
  AND created_at >= $4
ORDER BY created_at DESC
LIMIT 1
`

type FindRecentSimilarTimeEntryParams struct {
	UserID    string           `json:"user_id"`
	Route     string           `json:"route"`
	StoryID   pgtype.Int4      `json:"story_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type FindRecentSimilarTimeEntryRow struct {
	TrackingID       int32       `json:"tracking_id"`
	TotalTimeSeconds pgtype.Int4 `json:"total_time_seconds"`
}

func (q *Queries) FindRecentSimilarTimeEntry(ctx context.Context, arg FindRecentSimilarTimeEntryParams) (FindRecentSimilarTimeEntryRow, error) {
	row := q.db.QueryRow(ctx, findRecentSimilarTimeEntry,
		arg.UserID,
		arg.Route,
		arg.StoryID,
		arg.CreatedAt,
	)
	var i FindRecentSimilarTimeEntryRow
	err := row.Scan(&i.TrackingID, &i.TotalTimeSeconds)
	return i, err
}

const getActiveAnonymousTimeEntry = `-- name: GetActiveAnonymousTimeEntry :one
SELECT tracking_id, session_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM anonymous_time_tracking
WHERE session_id = $1 AND route = $2 AND story_id IS NOT DISTINCT FROM $3 AND ended_at IS NULL
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveAnonymousTimeEntryParams struct {
	SessionID string      `json:"session_id"`
	Route     string      `json:"route"`
	StoryID   pgtype.Int4 `json:"story_id"`
}

func (q *Queries) GetActiveAnonymousTimeEntry(ctx context.Context, arg GetActiveAnonymousTimeEntryParams) (AnonymousTimeTracking, error) {
	row := q.db.QueryRow(ctx, getActiveAnonymousTimeEntry, arg.SessionID, arg.Route, arg.StoryID)
	var i AnonymousTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.SessionID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveTimeEntry = `-- name: GetActiveTimeEntry :one
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE user_id = $1 AND route = $2 AND story_id IS NOT DISTINCT FROM $3 AND ended_at IS NULL
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveTimeEntryParams struct {
	UserID  string      `json:"user_id"`
	Route   string      `json:"route"`
	StoryID pgtype.Int4 `json:"story_id"`
}

func (q *Queries) GetActiveTimeEntry(ctx context.Context, arg GetActiveTimeEntryParams) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, getActiveTimeEntry, arg.UserID, arg.Route, arg.StoryID)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getAnonymousTimeEntryByID = `-- name: GetAnonymousTimeEntryByID :one
SELECT tracking_id, session_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM anonymous_time_tracking
WHERE tracking_id = $1
`

func (q *Queries) GetAnonymousTimeEntryByID(ctx context.Context, trackingID int32) (AnonymousTimeTracking, error) {
	row := q.db.QueryRow(ctx, getAnonymousTimeEntryByID, trackingID)
	var i AnonymousTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.SessionID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getRecentTimeEntriesForUser = `-- name: GetRecentTimeEntriesForUser :many
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE user_id = $1 AND created_at >= $2
ORDER BY created_at DESC
`

type GetRecentTimeEntriesForUserParams struct {
	UserID    string           `json:"user_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetRecentTimeEntriesForUser(ctx context.Context, arg GetRecentTimeEntriesForUserParams) ([]UserTimeTracking, error) {
	rows, err := q.db.Query(ctx, getRecentTimeEntriesForUser, arg.UserID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTimeTracking{}
	for rows.Next() {
		var i UserTimeTracking
		if err := rows.Scan(
			&i.TrackingID,
			&i.UserID,
			&i.Route,
			&i.StoryID,
			&i.StartedAt,
			&i.EndedAt,
			&i.TotalTimeSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeEntriesForStory = `-- name: GetTimeEntriesForStory :many
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE story_id = $1
ORDER BY started_at DESC
`

func (q *Queries) GetTimeEntriesForStory(ctx context.Context, storyID pgtype.Int4) ([]UserTimeTracking, error) {
	rows, err := q.db.Query(ctx, getTimeEntriesForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTimeTracking{}
	for rows.Next() {
		var i UserTimeTracking
		if err := rows.Scan(
			&i.TrackingID,
			&i.UserID,
			&i.Route,
			&i.StoryID,
			&i.StartedAt,
			&i.EndedAt,
			&i.TotalTimeSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeEntriesForUser = `-- name: GetTimeEntriesForUser :many
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE user_id = $1
ORDER BY started_at DESC
`

func (q *Queries) GetTimeEntriesForUser(ctx context.Context, userID string) ([]UserTimeTracking, error) {
	rows, err := q.db.Query(ctx, getTimeEntriesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTimeTracking{}
	for rows.Next() {
		var i UserTimeTracking
		if err := rows.Scan(
			&i.TrackingID,
			&i.UserID,
			&i.Route,
			&i.StoryID,
			&i.StartedAt,
			&i.EndedAt,
			&i.TotalTimeSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeEntryByID = `-- name: GetTimeEntryByID :one
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE tracking_id = $1
`

func (q *Queries) GetTimeEntryByID(ctx context.Context, trackingID int32) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, getTimeEntryByID, trackingID)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getUserStoryTimeTracking = `-- name: GetUserStoryTimeTracking :one
SELECT
    COALESCE(SUM(CASE WHEN route LIKE '%vocab%' THEN total_time_seconds END), 0) as vocab_time_seconds,
    COALESCE(SUM(CASE WHEN route LIKE '%grammar%' THEN total_time_seconds END), 0) as grammar_time_seconds,
    COALESCE(SUM(CASE WHEN route LIKE '%translate%' THEN total_time_seconds END), 0) as translation_time_seconds,
    COALESCE(SUM(CASE WHEN route LIKE '%audio%' OR route LIKE '%video%' THEN total_time_seconds END), 0) as video_time_seconds
FROM user_time_tracking
WHERE user_id = $1 AND story_id = $2 AND ended_at IS NOT NULL
`

type GetUserStoryTimeTrackingParams struct {
	UserID  string      `json:"user_id"`
	StoryID pgtype.Int4 `json:"story_id"`
}

type GetUserStoryTimeTrackingRow struct {
	VocabTimeSeconds       interface{} `json:"vocab_time_seconds"`
	GrammarTimeSeconds     interface{} `json:"grammar_time_seconds"`
	TranslationTimeSeconds interface{} `json:"translation_time_seconds"`
	VideoTimeSeconds       interface{} `json:"video_time_seconds"`
}

func (q *Queries) GetUserStoryTimeTracking(ctx context.Context, arg GetUserStoryTimeTrackingParams) (GetUserStoryTimeTrackingRow, error) {
	row := q.db.QueryRow(ctx, getUserStoryTimeTracking, arg.UserID, arg.StoryID)
	var i GetUserStoryTimeTrackingRow
	err := row.Scan(
		&i.VocabTimeSeconds,
		&i.GrammarTimeSeconds,
		&i.TranslationTimeSeconds,
		&i.VideoTimeSeconds,
	)
	return i, err
}

const updateAnonymousTimeEntry = `-- name: UpdateAnonymousTimeEntry :one
UPDATE anonymous_time_tracking
SET ended_at = $2, total_time_seconds = $3
WHERE tracking_id = $1
RETURNING tracking_id, session_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type UpdateAnonymousTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) UpdateAnonymousTimeEntry(ctx context.Context, arg UpdateAnonymousTimeEntryParams) (AnonymousTimeTracking, error) {
	row := q.db.QueryRow(ctx, updateAnonymousTimeEntry, arg.TrackingID, arg.EndedAt, arg.TotalTimeSeconds)
	var i AnonymousTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.SessionID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const updateTimeEntry = `-- name: UpdateTimeEntry :one
UPDATE user_time_tracking
SET ended_at = $2, total_time_seconds = $3
WHERE tracking_id = $1
RETURNING tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type UpdateTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) UpdateTimeEntry(ctx context.Context, arg UpdateTimeEntryParams) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, updateTimeEntry, arg.TrackingID, arg.EndedAt, arg.TotalTimeSeconds)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const updateTimeEntryIfBigger = `-- name: UpdateTimeEntryIfBigger :exec
UPDATE user_time_tracking
SET total_time_seconds = GREATEST(total_time_seconds, $2),
    ended_at = $3
WHERE tracking_id = $1
`

type UpdateTimeEntryIfBiggerParams struct {
	TrackingID       int32            `json:"tracking_id"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
}

func (q *Queries) UpdateTimeEntryIfBigger(ctx context.Context, arg UpdateTimeEntryIfBiggerParams) error {
	_, err := q.db.Exec(ctx, updateTimeEntryIfBigger, arg.TrackingID, arg.TotalTimeSeconds, arg.EndedAt)
	return err
}

const upsertTimeEntry = `-- name: UpsertTimeEntry :one
INSERT INTO user_time_tracking (user_id, route, story_id, started_at, ended_at, total_time_seconds)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (tracking_id)
DO UPDATE SET
    total_time_seconds = GREATEST(user_time_tracking.total_time_seconds, EXCLUDED.total_time_seconds),
    ended_at = EXCLUDED.ended_at
RETURNING tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type UpsertTimeEntryParams struct {
	UserID           string           `json:"user_id"`
	Route            string           `json:"route"`
	StoryID          pgtype.Int4      `json:"story_id"`
	StartedAt        pgtype.Timestamp `json:"started_at"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) UpsertTimeEntry(ctx context.Context, arg UpsertTimeEntryParams) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, upsertTimeEntry,
		arg.UserID,
		arg.Route,
		arg.StoryID,
		arg.StartedAt,
		arg.EndedAt,
		arg.TotalTimeSeconds,
	)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}
