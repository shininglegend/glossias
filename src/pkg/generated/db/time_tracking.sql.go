// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: time_tracking.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const closeAnonymousTimeEntry = `-- name: CloseAnonymousTimeEntry :exec
UPDATE anonymous_time_tracking
SET ended_at = $2, total_time_seconds = $3
WHERE tracking_id = $1
`

type CloseAnonymousTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) CloseAnonymousTimeEntry(ctx context.Context, arg CloseAnonymousTimeEntryParams) error {
	_, err := q.db.Exec(ctx, closeAnonymousTimeEntry, arg.TrackingID, arg.EndedAt, arg.TotalTimeSeconds)
	return err
}

const closeTimeEntry = `-- name: CloseTimeEntry :exec
UPDATE user_time_tracking
SET ended_at = $2, total_time_seconds = $3
WHERE tracking_id = $1
`

type CloseTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) CloseTimeEntry(ctx context.Context, arg CloseTimeEntryParams) error {
	_, err := q.db.Exec(ctx, closeTimeEntry, arg.TrackingID, arg.EndedAt, arg.TotalTimeSeconds)
	return err
}

const createAnonymousTimeEntry = `-- name: CreateAnonymousTimeEntry :one

INSERT INTO anonymous_time_tracking (session_id, route, story_id, started_at)
VALUES ($1, $2, $3, $4)
RETURNING tracking_id, session_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type CreateAnonymousTimeEntryParams struct {
	SessionID string           `json:"session_id"`
	Route     string           `json:"route"`
	StoryID   pgtype.Int4      `json:"story_id"`
	StartedAt pgtype.Timestamp `json:"started_at"`
}

// Anonymous time tracking queries
func (q *Queries) CreateAnonymousTimeEntry(ctx context.Context, arg CreateAnonymousTimeEntryParams) (AnonymousTimeTracking, error) {
	row := q.db.QueryRow(ctx, createAnonymousTimeEntry,
		arg.SessionID,
		arg.Route,
		arg.StoryID,
		arg.StartedAt,
	)
	var i AnonymousTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.SessionID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const createTimeEntry = `-- name: CreateTimeEntry :one

INSERT INTO user_time_tracking (user_id, route, story_id, started_at)
VALUES ($1, $2, $3, $4)
RETURNING tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type CreateTimeEntryParams struct {
	UserID    string           `json:"user_id"`
	Route     string           `json:"route"`
	StoryID   pgtype.Int4      `json:"story_id"`
	StartedAt pgtype.Timestamp `json:"started_at"`
}

// Time tracking queries
func (q *Queries) CreateTimeEntry(ctx context.Context, arg CreateTimeEntryParams) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, createTimeEntry,
		arg.UserID,
		arg.Route,
		arg.StoryID,
		arg.StartedAt,
	)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const deleteOldAnonymousEntries = `-- name: DeleteOldAnonymousEntries :exec
DELETE FROM anonymous_time_tracking
WHERE created_at < $1
`

func (q *Queries) DeleteOldAnonymousEntries(ctx context.Context, createdAt pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, deleteOldAnonymousEntries, createdAt)
	return err
}

const getActiveAnonymousTimeEntry = `-- name: GetActiveAnonymousTimeEntry :one
SELECT tracking_id, session_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM anonymous_time_tracking
WHERE session_id = $1 AND route = $2 AND story_id IS NOT DISTINCT FROM $3
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveAnonymousTimeEntryParams struct {
	SessionID string      `json:"session_id"`
	Route     string      `json:"route"`
	StoryID   pgtype.Int4 `json:"story_id"`
}

func (q *Queries) GetActiveAnonymousTimeEntry(ctx context.Context, arg GetActiveAnonymousTimeEntryParams) (AnonymousTimeTracking, error) {
	row := q.db.QueryRow(ctx, getActiveAnonymousTimeEntry, arg.SessionID, arg.Route, arg.StoryID)
	var i AnonymousTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.SessionID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveTimeEntry = `-- name: GetActiveTimeEntry :one
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE user_id = $1 AND route = $2 AND story_id IS NOT DISTINCT FROM $3
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveTimeEntryParams struct {
	UserID  string      `json:"user_id"`
	Route   string      `json:"route"`
	StoryID pgtype.Int4 `json:"story_id"`
}

func (q *Queries) GetActiveTimeEntry(ctx context.Context, arg GetActiveTimeEntryParams) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, getActiveTimeEntry, arg.UserID, arg.Route, arg.StoryID)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getAnonymousTimeEntryByID = `-- name: GetAnonymousTimeEntryByID :one
SELECT tracking_id, session_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM anonymous_time_tracking
WHERE tracking_id = $1
`

func (q *Queries) GetAnonymousTimeEntryByID(ctx context.Context, trackingID int32) (AnonymousTimeTracking, error) {
	row := q.db.QueryRow(ctx, getAnonymousTimeEntryByID, trackingID)
	var i AnonymousTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.SessionID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getTimeEntriesForStory = `-- name: GetTimeEntriesForStory :many
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE story_id = $1
ORDER BY started_at DESC
`

func (q *Queries) GetTimeEntriesForStory(ctx context.Context, storyID pgtype.Int4) ([]UserTimeTracking, error) {
	rows, err := q.db.Query(ctx, getTimeEntriesForStory, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTimeTracking{}
	for rows.Next() {
		var i UserTimeTracking
		if err := rows.Scan(
			&i.TrackingID,
			&i.UserID,
			&i.Route,
			&i.StoryID,
			&i.StartedAt,
			&i.EndedAt,
			&i.TotalTimeSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeEntriesForUser = `-- name: GetTimeEntriesForUser :many
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE user_id = $1
ORDER BY started_at DESC
`

func (q *Queries) GetTimeEntriesForUser(ctx context.Context, userID string) ([]UserTimeTracking, error) {
	rows, err := q.db.Query(ctx, getTimeEntriesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserTimeTracking{}
	for rows.Next() {
		var i UserTimeTracking
		if err := rows.Scan(
			&i.TrackingID,
			&i.UserID,
			&i.Route,
			&i.StoryID,
			&i.StartedAt,
			&i.EndedAt,
			&i.TotalTimeSeconds,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimeEntryByID = `-- name: GetTimeEntryByID :one
SELECT tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
FROM user_time_tracking
WHERE tracking_id = $1
`

func (q *Queries) GetTimeEntryByID(ctx context.Context, trackingID int32) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, getTimeEntryByID, trackingID)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const getUserStoryTimeTracking = `-- name: GetUserStoryTimeTracking :one
SELECT
    COALESCE(SUM(CASE WHEN route LIKE '%vocab%' THEN total_time_seconds END), 0) as vocab_time_seconds,
    COALESCE(SUM(CASE WHEN route LIKE '%grammar%' THEN total_time_seconds END), 0) as grammar_time_seconds,
    COALESCE(SUM(CASE WHEN route LIKE '%translate%' THEN total_time_seconds END), 0) as translation_time_seconds,
    COALESCE(SUM(CASE WHEN route LIKE '%audio%' OR route LIKE '%video%' THEN total_time_seconds END), 0) as video_time_seconds
FROM user_time_tracking
WHERE user_id = $1 AND story_id = $2 AND ended_at IS NOT NULL
`

type GetUserStoryTimeTrackingParams struct {
	UserID  string      `json:"user_id"`
	StoryID pgtype.Int4 `json:"story_id"`
}

type GetUserStoryTimeTrackingRow struct {
	VocabTimeSeconds       interface{} `json:"vocab_time_seconds"`
	GrammarTimeSeconds     interface{} `json:"grammar_time_seconds"`
	TranslationTimeSeconds interface{} `json:"translation_time_seconds"`
	VideoTimeSeconds       interface{} `json:"video_time_seconds"`
}

func (q *Queries) GetUserStoryTimeTracking(ctx context.Context, arg GetUserStoryTimeTrackingParams) (GetUserStoryTimeTrackingRow, error) {
	row := q.db.QueryRow(ctx, getUserStoryTimeTracking, arg.UserID, arg.StoryID)
	var i GetUserStoryTimeTrackingRow
	err := row.Scan(
		&i.VocabTimeSeconds,
		&i.GrammarTimeSeconds,
		&i.TranslationTimeSeconds,
		&i.VideoTimeSeconds,
	)
	return i, err
}

const updateAnonymousTimeEntry = `-- name: UpdateAnonymousTimeEntry :one
UPDATE anonymous_time_tracking
SET ended_at = $2, total_time_seconds = $3
WHERE tracking_id = $1
RETURNING tracking_id, session_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type UpdateAnonymousTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) UpdateAnonymousTimeEntry(ctx context.Context, arg UpdateAnonymousTimeEntryParams) (AnonymousTimeTracking, error) {
	row := q.db.QueryRow(ctx, updateAnonymousTimeEntry, arg.TrackingID, arg.EndedAt, arg.TotalTimeSeconds)
	var i AnonymousTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.SessionID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}

const updateTimeEntry = `-- name: UpdateTimeEntry :one
UPDATE user_time_tracking
SET ended_at = $2, total_time_seconds = $3
WHERE tracking_id = $1
RETURNING tracking_id, user_id, route, story_id, started_at, ended_at, total_time_seconds, created_at
`

type UpdateTimeEntryParams struct {
	TrackingID       int32            `json:"tracking_id"`
	EndedAt          pgtype.Timestamp `json:"ended_at"`
	TotalTimeSeconds pgtype.Int4      `json:"total_time_seconds"`
}

func (q *Queries) UpdateTimeEntry(ctx context.Context, arg UpdateTimeEntryParams) (UserTimeTracking, error) {
	row := q.db.QueryRow(ctx, updateTimeEntry, arg.TrackingID, arg.EndedAt, arg.TotalTimeSeconds)
	var i UserTimeTracking
	err := row.Scan(
		&i.TrackingID,
		&i.UserID,
		&i.Route,
		&i.StoryID,
		&i.StartedAt,
		&i.EndedAt,
		&i.TotalTimeSeconds,
		&i.CreatedAt,
	)
	return i, err
}
