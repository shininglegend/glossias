// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: translation_requests.sql

package db

import (
	"context"
)

const createTranslationRequest = `-- name: CreateTranslationRequest :one

INSERT INTO translation_requests (user_id, story_id, requested_lines)
VALUES ($1, $2, $3)
RETURNING request_id, user_id, story_id, requested_lines, created_at
`

type CreateTranslationRequestParams struct {
	UserID         string  `json:"user_id"`
	StoryID        int32   `json:"story_id"`
	RequestedLines []int32 `json:"requested_lines"`
}

// Translation requests management queries
func (q *Queries) CreateTranslationRequest(ctx context.Context, arg CreateTranslationRequestParams) (TranslationRequest, error) {
	row := q.db.QueryRow(ctx, createTranslationRequest, arg.UserID, arg.StoryID, arg.RequestedLines)
	var i TranslationRequest
	err := row.Scan(
		&i.RequestID,
		&i.UserID,
		&i.StoryID,
		&i.RequestedLines,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTranslationRequest = `-- name: DeleteTranslationRequest :exec
DELETE FROM translation_requests
WHERE user_id = $1 AND story_id = $2
`

type DeleteTranslationRequestParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

func (q *Queries) DeleteTranslationRequest(ctx context.Context, arg DeleteTranslationRequestParams) error {
	_, err := q.db.Exec(ctx, deleteTranslationRequest, arg.UserID, arg.StoryID)
	return err
}

const getStoryTranslationRequests = `-- name: GetStoryTranslationRequests :many
SELECT request_id, user_id, story_id, requested_lines, created_at
FROM translation_requests
WHERE story_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetStoryTranslationRequests(ctx context.Context, storyID int32) ([]TranslationRequest, error) {
	rows, err := q.db.Query(ctx, getStoryTranslationRequests, storyID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TranslationRequest{}
	for rows.Next() {
		var i TranslationRequest
		if err := rows.Scan(
			&i.RequestID,
			&i.UserID,
			&i.StoryID,
			&i.RequestedLines,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTranslationRequest = `-- name: GetTranslationRequest :one
SELECT request_id, user_id, story_id, requested_lines, created_at
FROM translation_requests
WHERE user_id = $1 AND story_id = $2
`

type GetTranslationRequestParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

func (q *Queries) GetTranslationRequest(ctx context.Context, arg GetTranslationRequestParams) (TranslationRequest, error) {
	row := q.db.QueryRow(ctx, getTranslationRequest, arg.UserID, arg.StoryID)
	var i TranslationRequest
	err := row.Scan(
		&i.RequestID,
		&i.UserID,
		&i.StoryID,
		&i.RequestedLines,
		&i.CreatedAt,
	)
	return i, err
}

const getTranslationRequestByID = `-- name: GetTranslationRequestByID :one
SELECT request_id, user_id, story_id, requested_lines, created_at
FROM translation_requests
WHERE request_id = $1
`

func (q *Queries) GetTranslationRequestByID(ctx context.Context, requestID int32) (TranslationRequest, error) {
	row := q.db.QueryRow(ctx, getTranslationRequestByID, requestID)
	var i TranslationRequest
	err := row.Scan(
		&i.RequestID,
		&i.UserID,
		&i.StoryID,
		&i.RequestedLines,
		&i.CreatedAt,
	)
	return i, err
}

const getUserTranslationRequests = `-- name: GetUserTranslationRequests :many
SELECT request_id, user_id, story_id, requested_lines, created_at
FROM translation_requests
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetUserTranslationRequests(ctx context.Context, userID string) ([]TranslationRequest, error) {
	rows, err := q.db.Query(ctx, getUserTranslationRequests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TranslationRequest{}
	for rows.Next() {
		var i TranslationRequest
		if err := rows.Scan(
			&i.RequestID,
			&i.UserID,
			&i.StoryID,
			&i.RequestedLines,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTranslationStatusForStory = `-- name: GetUserTranslationStatusForStory :one
SELECT
    EXISTS(SELECT 1 FROM translation_requests tr WHERE tr.user_id = $1 AND tr.story_id = $2) as completed,
    COALESCE((SELECT tr2.requested_lines FROM translation_requests tr2 WHERE tr2.user_id = $1 AND tr2.story_id = $2), ARRAY[]::INTEGER[]) as requested_lines
`

type GetUserTranslationStatusForStoryParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

type GetUserTranslationStatusForStoryRow struct {
	Completed      bool        `json:"completed"`
	RequestedLines interface{} `json:"requested_lines"`
}

func (q *Queries) GetUserTranslationStatusForStory(ctx context.Context, arg GetUserTranslationStatusForStoryParams) (GetUserTranslationStatusForStoryRow, error) {
	row := q.db.QueryRow(ctx, getUserTranslationStatusForStory, arg.UserID, arg.StoryID)
	var i GetUserTranslationStatusForStoryRow
	err := row.Scan(&i.Completed, &i.RequestedLines)
	return i, err
}

const translationRequestExists = `-- name: TranslationRequestExists :one
SELECT EXISTS(
    SELECT 1 FROM translation_requests
    WHERE user_id = $1 AND story_id = $2
) as exists
`

type TranslationRequestExistsParams struct {
	UserID  string `json:"user_id"`
	StoryID int32  `json:"story_id"`
}

func (q *Queries) TranslationRequestExists(ctx context.Context, arg TranslationRequestExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, translationRequestExists, arg.UserID, arg.StoryID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
