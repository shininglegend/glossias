// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: utility.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkFootnoteExists = `-- name: CheckFootnoteExists :one
SELECT id FROM footnotes f
WHERE f.story_id = $1 AND f.line_number = $2 AND f.footnote_text = $3
LIMIT 1
`

type CheckFootnoteExistsParams struct {
	StoryID      pgtype.Int4 `json:"story_id"`
	LineNumber   pgtype.Int4 `json:"line_number"`
	FootnoteText string      `json:"footnote_text"`
}

func (q *Queries) CheckFootnoteExists(ctx context.Context, arg CheckFootnoteExistsParams) (int32, error) {
	row := q.db.QueryRow(ctx, checkFootnoteExists, arg.StoryID, arg.LineNumber, arg.FootnoteText)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const checkGrammarExists = `-- name: CheckGrammarExists :one
SELECT EXISTS(
    SELECT 1 FROM grammar_items
    WHERE story_id = $1 AND line_number = $2 AND text = $3
    AND position_start = $4 AND position_end = $5
)
`

type CheckGrammarExistsParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Text          string      `json:"text"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) CheckGrammarExists(ctx context.Context, arg CheckGrammarExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkGrammarExists,
		arg.StoryID,
		arg.LineNumber,
		arg.Text,
		arg.PositionStart,
		arg.PositionEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkVocabularyExists = `-- name: CheckVocabularyExists :one
SELECT EXISTS(
    SELECT 1 FROM vocabulary_items
    WHERE story_id = $1 AND line_number = $2 AND word = $3 AND lexical_form = $4
    AND position_start = $5 AND position_end = $6
)
`

type CheckVocabularyExistsParams struct {
	StoryID       pgtype.Int4 `json:"story_id"`
	LineNumber    pgtype.Int4 `json:"line_number"`
	Word          string      `json:"word"`
	LexicalForm   string      `json:"lexical_form"`
	PositionStart int32       `json:"position_start"`
	PositionEnd   int32       `json:"position_end"`
}

func (q *Queries) CheckVocabularyExists(ctx context.Context, arg CheckVocabularyExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkVocabularyExists,
		arg.StoryID,
		arg.LineNumber,
		arg.Word,
		arg.LexicalForm,
		arg.PositionStart,
		arg.PositionEnd,
	)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const deleteAllGrammarForStory = `-- name: DeleteAllGrammarForStory :exec
DELETE FROM grammar_items WHERE story_id = $1
`

func (q *Queries) DeleteAllGrammarForStory(ctx context.Context, storyID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteAllGrammarForStory, storyID)
	return err
}

const deleteAllLineAnnotations = `-- name: DeleteAllLineAnnotations :exec
DELETE FROM footnotes WHERE story_id = $1 AND line_number = $2
`

type DeleteAllLineAnnotationsParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
}

func (q *Queries) DeleteAllLineAnnotations(ctx context.Context, arg DeleteAllLineAnnotationsParams) error {
	_, err := q.db.Exec(ctx, deleteAllLineAnnotations, arg.StoryID, arg.LineNumber)
	return err
}

const deleteAllStoryAnnotations = `-- name: DeleteAllStoryAnnotations :exec
DELETE FROM footnotes WHERE story_id = $1
`

func (q *Queries) DeleteAllStoryAnnotations(ctx context.Context, storyID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteAllStoryAnnotations, storyID)
	return err
}

const deleteAllVocabularyForStory = `-- name: DeleteAllVocabularyForStory :exec
DELETE FROM vocabulary_items WHERE story_id = $1
`

func (q *Queries) DeleteAllVocabularyForStory(ctx context.Context, storyID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteAllVocabularyForStory, storyID)
	return err
}

const lineExists = `-- name: LineExists :one
SELECT EXISTS(SELECT 1 FROM story_lines WHERE story_id = $1 AND line_number = $2)
`

type LineExistsParams struct {
	StoryID    int32 `json:"story_id"`
	LineNumber int32 `json:"line_number"`
}

func (q *Queries) LineExists(ctx context.Context, arg LineExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, lineExists, arg.StoryID, arg.LineNumber)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const storyExists = `-- name: StoryExists :one
SELECT EXISTS(SELECT 1 FROM stories WHERE story_id = $1)
`

func (q *Queries) StoryExists(ctx context.Context, storyID int32) (bool, error) {
	row := q.db.QueryRow(ctx, storyExists, storyID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateStoryRevision = `-- name: UpdateStoryRevision :exec
UPDATE stories
SET last_revision = CURRENT_TIMESTAMP
WHERE story_id = $1
`

func (q *Queries) UpdateStoryRevision(ctx context.Context, storyID int32) error {
	_, err := q.db.Exec(ctx, updateStoryRevision, storyID)
	return err
}
