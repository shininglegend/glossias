// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vocab.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkAllVocabCompleteForLineForUser = `-- name: CheckAllVocabCompleteForLineForUser :one

SELECT NOT EXISTS (
    SELECT 1
    FROM vocabulary_items vi
    WHERE vi.story_id = $1
      AND vi.line_number = $2
      AND vi.id NOT IN (
          SELECT vca.vocab_item_id
          FROM vocab_correct_answers vca
          WHERE vca.user_id = $3 AND vca.story_id = $1
      )
) as all_complete
`

type CheckAllVocabCompleteForLineForUserParams struct {
	StoryID    pgtype.Int4 `json:"story_id"`
	LineNumber pgtype.Int4 `json:"line_number"`
	UserID     string      `json:"user_id"`
}

// Vocabulary-related queries
func (q *Queries) CheckAllVocabCompleteForLineForUser(ctx context.Context, arg CheckAllVocabCompleteForLineForUserParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkAllVocabCompleteForLineForUser, arg.StoryID, arg.LineNumber, arg.UserID)
	var all_complete bool
	err := row.Scan(&all_complete)
	return all_complete, err
}

const getIncompleteVocabForUser = `-- name: GetIncompleteVocabForUser :many
SELECT vi.line_number, vi.position_start
FROM vocabulary_items vi
WHERE vi.story_id = $1
  AND vi.id NOT IN (
      SELECT vca.vocab_item_id
      FROM vocab_correct_answers vca
      WHERE vca.user_id = $2 AND vca.story_id = $1
  )
ORDER BY vi.line_number, vi.position_start
`

type GetIncompleteVocabForUserParams struct {
	StoryID pgtype.Int4 `json:"story_id"`
	UserID  string      `json:"user_id"`
}

type GetIncompleteVocabForUserRow struct {
	LineNumber    pgtype.Int4 `json:"line_number"`
	PositionStart int32       `json:"position_start"`
}

func (q *Queries) GetIncompleteVocabForUser(ctx context.Context, arg GetIncompleteVocabForUserParams) ([]GetIncompleteVocabForUserRow, error) {
	rows, err := q.db.Query(ctx, getIncompleteVocabForUser, arg.StoryID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetIncompleteVocabForUserRow{}
	for rows.Next() {
		var i GetIncompleteVocabForUserRow
		if err := rows.Scan(&i.LineNumber, &i.PositionStart); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveVocabIncorrectAnswer = `-- name: SaveVocabIncorrectAnswer :exec
INSERT INTO vocab_incorrect_answers (user_id, story_id, line_number, vocab_item_id, incorrect_answer)
VALUES ($1, $2, $3, $4, $5)
`

type SaveVocabIncorrectAnswerParams struct {
	UserID          string `json:"user_id"`
	StoryID         int32  `json:"story_id"`
	LineNumber      int32  `json:"line_number"`
	VocabItemID     int32  `json:"vocab_item_id"`
	IncorrectAnswer string `json:"incorrect_answer"`
}

func (q *Queries) SaveVocabIncorrectAnswer(ctx context.Context, arg SaveVocabIncorrectAnswerParams) error {
	_, err := q.db.Exec(ctx, saveVocabIncorrectAnswer,
		arg.UserID,
		arg.StoryID,
		arg.LineNumber,
		arg.VocabItemID,
		arg.IncorrectAnswer,
	)
	return err
}

const saveVocabScore = `-- name: SaveVocabScore :exec
INSERT INTO vocab_correct_answers (user_id, story_id, line_number, vocab_item_id)
VALUES ($1, $2, $3, $4)
`

type SaveVocabScoreParams struct {
	UserID      string `json:"user_id"`
	StoryID     int32  `json:"story_id"`
	LineNumber  int32  `json:"line_number"`
	VocabItemID int32  `json:"vocab_item_id"`
}

func (q *Queries) SaveVocabScore(ctx context.Context, arg SaveVocabScoreParams) error {
	_, err := q.db.Exec(ctx, saveVocabScore,
		arg.UserID,
		arg.StoryID,
		arg.LineNumber,
		arg.VocabItemID,
	)
	return err
}
